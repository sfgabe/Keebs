   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.process_hand_swap,"ax",@progbits
  11               	.global	process_hand_swap
  13               	process_hand_swap:
  14               	.LVL0:
  15               	.LFB109:
  16               		.file 1 "tmk_core/common/action.c"
   1:tmk_core/common/action.c **** /*
   2:tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/action.c **** 
   4:tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/action.c **** (at your option) any later version.
   8:tmk_core/common/action.c **** 
   9:tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/action.c **** GNU General Public License for more details.
  13:tmk_core/common/action.c **** 
  14:tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/action.c **** */
  17:tmk_core/common/action.c **** #include "host.h"
  18:tmk_core/common/action.c **** #include "keycode.h"
  19:tmk_core/common/action.c **** #include "keyboard.h"
  20:tmk_core/common/action.c **** #include "mousekey.h"
  21:tmk_core/common/action.c **** #include "command.h"
  22:tmk_core/common/action.c **** #include "led.h"
  23:tmk_core/common/action.c **** #include "action_layer.h"
  24:tmk_core/common/action.c **** #include "action_tapping.h"
  25:tmk_core/common/action.c **** #include "action_macro.h"
  26:tmk_core/common/action.c **** #include "action_util.h"
  27:tmk_core/common/action.c **** #include "action.h"
  28:tmk_core/common/action.c **** #include "wait.h"
  29:tmk_core/common/action.c **** 
  30:tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
  31:tmk_core/common/action.c **** #    include "backlight.h"
  32:tmk_core/common/action.c **** #endif
  33:tmk_core/common/action.c **** 
  34:tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  35:tmk_core/common/action.c **** #    include "debug.h"
  36:tmk_core/common/action.c **** #else
  37:tmk_core/common/action.c **** #    include "nodebug.h"
  38:tmk_core/common/action.c **** #endif
  39:tmk_core/common/action.c **** 
  40:tmk_core/common/action.c **** int tp_buttons;
  41:tmk_core/common/action.c **** 
  42:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  43:tmk_core/common/action.c **** int retro_tapping_counter = 0;
  44:tmk_core/common/action.c **** #endif
  45:tmk_core/common/action.c **** 
  46:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  47:tmk_core/common/action.c **** #    include <fauxclicky.h>
  48:tmk_core/common/action.c **** #endif
  49:tmk_core/common/action.c **** 
  50:tmk_core/common/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:tmk_core/common/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:tmk_core/common/action.c **** #endif
  53:tmk_core/common/action.c **** 
  54:tmk_core/common/action.c **** #ifndef TAP_CODE_DELAY
  55:tmk_core/common/action.c **** #    define TAP_CODE_DELAY 0
  56:tmk_core/common/action.c **** #endif
  57:tmk_core/common/action.c **** #ifndef TAP_HOLD_CAPS_DELAY
  58:tmk_core/common/action.c **** #    define TAP_HOLD_CAPS_DELAY 80
  59:tmk_core/common/action.c **** #endif
  60:tmk_core/common/action.c **** /** \brief Called to execute an action.
  61:tmk_core/common/action.c ****  *
  62:tmk_core/common/action.c ****  * FIXME: Needs documentation.
  63:tmk_core/common/action.c ****  */
  64:tmk_core/common/action.c **** void action_exec(keyevent_t event) {
  65:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  66:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:tmk_core/common/action.c ****         dprint("EVENT: ");
  68:tmk_core/common/action.c ****         debug_event(event);
  69:tmk_core/common/action.c ****         dprintln();
  70:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  71:tmk_core/common/action.c ****         retro_tapping_counter++;
  72:tmk_core/common/action.c **** #endif
  73:tmk_core/common/action.c ****     }
  74:tmk_core/common/action.c **** 
  75:tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  76:tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  77:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  78:tmk_core/common/action.c ****     }
  79:tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  80:tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  81:tmk_core/common/action.c ****     }
  82:tmk_core/common/action.c ****     fauxclicky_check();
  83:tmk_core/common/action.c **** #endif
  84:tmk_core/common/action.c **** 
  85:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  86:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  87:tmk_core/common/action.c ****         process_hand_swap(&event);
  88:tmk_core/common/action.c ****     }
  89:tmk_core/common/action.c **** #endif
  90:tmk_core/common/action.c **** 
  91:tmk_core/common/action.c ****     keyrecord_t record = {.event = event};
  92:tmk_core/common/action.c **** 
  93:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
  94:tmk_core/common/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  95:tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  96:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  97:tmk_core/common/action.c ****     }
  98:tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  99:tmk_core/common/action.c ****         clear_oneshot_mods();
 100:tmk_core/common/action.c ****     }
 101:tmk_core/common/action.c **** #        ifdef SWAP_HANDS_ENABLE
 102:tmk_core/common/action.c ****     if (has_oneshot_swaphands_timed_out()) {
 103:tmk_core/common/action.c ****         clear_oneshot_swaphands();
 104:tmk_core/common/action.c ****     }
 105:tmk_core/common/action.c **** #        endif
 106:tmk_core/common/action.c **** #    endif
 107:tmk_core/common/action.c **** #endif
 108:tmk_core/common/action.c **** 
 109:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 110:tmk_core/common/action.c ****     action_tapping_process(record);
 111:tmk_core/common/action.c **** #else
 112:tmk_core/common/action.c ****     process_record(&record);
 113:tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
 114:tmk_core/common/action.c ****         dprint("processed: ");
 115:tmk_core/common/action.c ****         debug_record(record);
 116:tmk_core/common/action.c ****         dprintln();
 117:tmk_core/common/action.c ****     }
 118:tmk_core/common/action.c **** #endif
 119:tmk_core/common/action.c **** }
 120:tmk_core/common/action.c **** 
 121:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 122:tmk_core/common/action.c **** bool swap_hands = false;
 123:tmk_core/common/action.c **** bool swap_held  = false;
 124:tmk_core/common/action.c **** 
 125:tmk_core/common/action.c **** /** \brief Process Hand Swap
 126:tmk_core/common/action.c ****  *
 127:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 128:tmk_core/common/action.c ****  */
 129:tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
  17               		.loc 1 129 43 view -0
  18               		.cfi_startproc
  19               		.loc 1 129 43 is_stmt 0 view .LVU1
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 DC01      		movw r26,r24
 130:tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
  33               		.loc 1 130 5 is_stmt 1 view .LVU2
 131:tmk_core/common/action.c **** 
 132:tmk_core/common/action.c ****     keypos_t         pos     = event->key;
  34               		.loc 1 132 5 view .LVU3
  35               	.LVL1:
 133:tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
  36               		.loc 1 133 5 view .LVU4
  37               		.loc 1 133 58 is_stmt 0 view .LVU5
  38 0006 8C91      		ld r24,X
  39               	.LVL2:
  40               		.loc 1 133 58 view .LVU6
  41 0008 682F      		mov r22,r24
  42 000a 70E0      		ldi r23,0
  43               		.loc 1 133 52 view .LVU7
  44 000c 21E0      		ldi r18,lo8(1)
  45 000e 30E0      		ldi r19,0
  46 0010 00C0      		rjmp 2f
  47               		1:
  48 0012 220F      		lsl r18
  49               		2:
  50 0014 8A95      		dec r24
  51 0016 02F4      		brpl 1b
  52               	.LVL3:
 134:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
  53               		.loc 1 134 5 is_stmt 1 view .LVU8
  54 0018 1196      		adiw r26,1
  55 001a 4C91      		ld r20,X
  56 001c 1197      		sbiw r26,1
  57 001e 50E0      		ldi r21,0
  58 0020 EA01      		movw r28,r20
  59 0022 C050      		subi r28,lo8(-(swap_state.5258))
  60 0024 D040      		sbci r29,hi8(-(swap_state.5258))
  61 0026 9881      		ld r25,Y
  62               		.loc 1 134 60 is_stmt 0 view .LVU9
  63 0028 1296      		adiw r26,2
  64 002a 8C91      		ld r24,X
  65 002c 1297      		sbiw r26,2
  66               	.LVL4:
  67               		.loc 1 134 60 view .LVU10
  68 002e 8823      		tst r24
  69 0030 01F0      		breq .L2
  70               		.loc 1 134 60 discriminator 1 view .LVU11
  71 0032 8091 0000 		lds r24,swap_hands
  72               	.LVL5:
 135:tmk_core/common/action.c **** 
 136:tmk_core/common/action.c ****     if (do_swap) {
  73               		.loc 1 136 5 is_stmt 1 discriminator 1 view .LVU12
  74               	.L11:
 134:tmk_core/common/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
  75               		.loc 1 134 60 is_stmt 0 discriminator 2 view .LVU13
  76 0036 8823      		tst r24
  77 0038 01F0      		breq .L5
 137:tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
  78               		.loc 1 137 9 is_stmt 1 view .LVU14
  79               		.loc 1 137 20 is_stmt 0 view .LVU15
  80 003a 86E0      		ldi r24,lo8(6)
  81 003c 849F      		mul r24,r20
  82 003e F001      		movw r30,r0
  83 0040 859F      		mul r24,r21
  84 0042 F00D      		add r31,r0
  85 0044 1124      		clr __zero_reg__
  86 0046 E60F      		add r30,r22
  87 0048 F71F      		adc r31,r23
  88 004a EE0F      		lsl r30
  89 004c FF1F      		rol r31
  90 004e E050      		subi r30,lo8(-(hand_swap_config))
  91 0050 F040      		sbci r31,hi8(-(hand_swap_config))
  92 0052 4081      		ld r20,Z
  93 0054 5181      		ldd r21,Z+1
  94 0056 4D93      		st X+,r20
  95 0058 5C93      		st X,r21
  96               	.LVL6:
 138:tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
  97               		.loc 1 138 9 is_stmt 1 view .LVU16
  98               		.loc 1 138 29 is_stmt 0 view .LVU17
  99 005a 292B      		or r18,r25
 100               	.LVL7:
 101               	.L12:
 139:tmk_core/common/action.c ****     } else {
 140:tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 102               		.loc 1 140 29 view .LVU18
 103 005c 2883      		st Y,r18
 104               	.LVL8:
 105               	/* epilogue start */
 141:tmk_core/common/action.c ****     }
 142:tmk_core/common/action.c **** }
 106               		.loc 1 142 1 view .LVU19
 107 005e DF91      		pop r29
 108 0060 CF91      		pop r28
 109 0062 0895      		ret
 110               	.LVL9:
 111               	.L2:
 134:tmk_core/common/action.c **** 
 112               		.loc 1 134 60 discriminator 2 view .LVU20
 113 0064 892F      		mov r24,r25
 114 0066 8223      		and r24,r18
 115 0068 00C0      		rjmp .L11
 116               	.L5:
 140:tmk_core/common/action.c ****     }
 117               		.loc 1 140 9 is_stmt 1 view .LVU21
 140:tmk_core/common/action.c ****     }
 118               		.loc 1 140 29 is_stmt 0 view .LVU22
 119 006a 2095      		com r18
 120               	.LVL10:
 140:tmk_core/common/action.c ****     }
 121               		.loc 1 140 29 view .LVU23
 122 006c 2923      		and r18,r25
 123 006e 00C0      		rjmp .L12
 124               		.cfi_endproc
 125               	.LFE109:
 127               		.section	.text.action_exec,"ax",@progbits
 128               	.global	action_exec
 130               	action_exec:
 131               	.LFB108:
  64:tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
 132               		.loc 1 64 36 is_stmt 1 view -0
 133               		.cfi_startproc
 134 0000 CF93      		push r28
 135               	.LCFI2:
 136               		.cfi_def_cfa_offset 3
 137               		.cfi_offset 28, -2
 138 0002 DF93      		push r29
 139               	.LCFI3:
 140               		.cfi_def_cfa_offset 4
 141               		.cfi_offset 29, -3
 142 0004 CDB7      		in r28,__SP_L__
 143 0006 DEB7      		in r29,__SP_H__
 144               	.LCFI4:
 145               		.cfi_def_cfa_register 28
 146 0008 2B97      		sbiw r28,11
 147               	.LCFI5:
 148               		.cfi_def_cfa_offset 15
 149 000a 0FB6      		in __tmp_reg__,__SREG__
 150 000c F894      		cli
 151 000e DEBF      		out __SP_H__,r29
 152 0010 0FBE      		out __SREG__,__tmp_reg__
 153 0012 CDBF      		out __SP_L__,r28
 154               	/* prologue: function */
 155               	/* frame size = 11 */
 156               	/* stack size = 13 */
 157               	.L__stack_usage = 13
 158 0014 4F83      		std Y+7,r20
 159 0016 5887      		std Y+8,r21
 160 0018 6987      		std Y+9,r22
 161 001a 7A87      		std Y+10,r23
 162 001c 8B87      		std Y+11,r24
  65:tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
 163               		.loc 1 65 5 view .LVU25
 164               	.LBB28:
 165               	.LBI28:
 166               		.file 2 "tmk_core/common/keyboard.h"
   1:tmk_core/common/keyboard.h **** /*
   2:tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/keyboard.h **** 
   4:tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/keyboard.h **** (at your option) any later version.
   8:tmk_core/common/keyboard.h **** 
   9:tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:tmk_core/common/keyboard.h **** 
  14:tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/keyboard.h **** */
  17:tmk_core/common/keyboard.h **** 
  18:tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:tmk_core/common/keyboard.h **** 
  21:tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:tmk_core/common/keyboard.h **** #include <stdint.h>
  23:tmk_core/common/keyboard.h **** 
  24:tmk_core/common/keyboard.h **** #ifdef __cplusplus
  25:tmk_core/common/keyboard.h **** extern "C" {
  26:tmk_core/common/keyboard.h **** #endif
  27:tmk_core/common/keyboard.h **** 
  28:tmk_core/common/keyboard.h **** /* key matrix position */
  29:tmk_core/common/keyboard.h **** typedef struct {
  30:tmk_core/common/keyboard.h ****     uint8_t col;
  31:tmk_core/common/keyboard.h ****     uint8_t row;
  32:tmk_core/common/keyboard.h **** } keypos_t;
  33:tmk_core/common/keyboard.h **** 
  34:tmk_core/common/keyboard.h **** /* key event */
  35:tmk_core/common/keyboard.h **** typedef struct {
  36:tmk_core/common/keyboard.h ****     keypos_t key;
  37:tmk_core/common/keyboard.h ****     bool     pressed;
  38:tmk_core/common/keyboard.h ****     uint16_t time;
  39:tmk_core/common/keyboard.h **** } keyevent_t;
  40:tmk_core/common/keyboard.h **** 
  41:tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  42:tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  43:tmk_core/common/keyboard.h **** 
  44:tmk_core/common/keyboard.h **** /* Rules for No Event:
  45:tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  46:tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  47:tmk_core/common/keyboard.h ****  */
  48:tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 167               		.loc 2 48 20 view .LVU26
 168               	.LBB29:
 169               		.loc 2 48 51 view .LVU27
 170               		.loc 2 48 74 is_stmt 0 view .LVU28
 171 001e 8A85      		ldd r24,Y+10
 172 0020 9B85      		ldd r25,Y+11
 173 0022 892B      		or r24,r25
 174 0024 01F0      		breq .L14
 175 0026 CA01      		movw r24,r20
 176 0028 8923      		and r24,r25
 177 002a 8F3F      		cpi r24,lo8(-1)
 178 002c 01F4      		brne .L15
 179               	.L14:
 180               	.LBE29:
 181               	.LBE28:
  91:tmk_core/common/action.c **** 
 182               		.loc 1 91 5 is_stmt 1 view .LVU29
  91:tmk_core/common/action.c **** 
 183               		.loc 1 91 17 is_stmt 0 view .LVU30
 184 002e 1E82      		std Y+6,__zero_reg__
 185 0030 1D82      		std Y+5,__zero_reg__
 186 0032 85E0      		ldi r24,lo8(5)
 187 0034 FE01      		movw r30,r28
 188 0036 3796      		adiw r30,7
 189 0038 DE01      		movw r26,r28
 190 003a 1196      		adiw r26,1
 191               		0:
 192 003c 0190      		ld r0,Z+
 193 003e 0D92      		st X+,r0
 194 0040 8A95      		dec r24
 195 0042 01F4      		brne 0b
 110:tmk_core/common/action.c **** #else
 196               		.loc 1 110 5 is_stmt 1 view .LVU31
 197 0044 4981      		ldd r20,Y+1
 198 0046 5A81      		ldd r21,Y+2
 199 0048 6B81      		ldd r22,Y+3
 200 004a 7C81      		ldd r23,Y+4
 201 004c 8D81      		ldd r24,Y+5
 202 004e 9E81      		ldd r25,Y+6
 203 0050 0E94 0000 		call action_tapping_process
 204               	.LVL11:
 205               	/* epilogue start */
 119:tmk_core/common/action.c **** 
 206               		.loc 1 119 1 is_stmt 0 view .LVU32
 207 0054 2B96      		adiw r28,11
 208 0056 0FB6      		in __tmp_reg__,__SREG__
 209 0058 F894      		cli
 210 005a DEBF      		out __SP_H__,r29
 211 005c 0FBE      		out __SREG__,__tmp_reg__
 212 005e CDBF      		out __SP_L__,r28
 213 0060 DF91      		pop r29
 214 0062 CF91      		pop r28
 215 0064 0895      		ret
 216               	.L15:
  69:tmk_core/common/action.c **** #ifdef RETRO_TAPPING
 217               		.loc 1 69 19 is_stmt 1 view .LVU33
  86:tmk_core/common/action.c ****         process_hand_swap(&event);
 218               		.loc 1 86 5 view .LVU34
  87:tmk_core/common/action.c ****     }
 219               		.loc 1 87 9 view .LVU35
 220 0066 CE01      		movw r24,r28
 221 0068 0796      		adiw r24,7
 222 006a 0E94 0000 		call process_hand_swap
 223               	.LVL12:
 224 006e 00C0      		rjmp .L14
 225               		.cfi_endproc
 226               	.LFE108:
 228               		.section	.text.process_record_quantum,"ax",@progbits
 229               		.weak	process_record_quantum
 231               	process_record_quantum:
 232               	.LVL13:
 233               	.LFB111:
 143:tmk_core/common/action.c **** #endif
 144:tmk_core/common/action.c **** 
 145:tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:tmk_core/common/action.c **** bool disable_action_cache = false;
 147:tmk_core/common/action.c **** 
 148:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:tmk_core/common/action.c ****     disable_action_cache = true;
 150:tmk_core/common/action.c ****     process_record(record);
 151:tmk_core/common/action.c ****     disable_action_cache = false;
 152:tmk_core/common/action.c **** }
 153:tmk_core/common/action.c **** #else
 154:tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:tmk_core/common/action.c **** #endif
 156:tmk_core/common/action.c **** 
 157:tmk_core/common/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 234               		.loc 1 157 72 view -0
 235               		.cfi_startproc
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 238               	/* stack size = 0 */
 239               	.L__stack_usage = 0
 240               		.loc 1 157 74 view .LVU37
 241               		.loc 1 157 1 is_stmt 0 view .LVU38
 242 0000 81E0      		ldi r24,lo8(1)
 243               	.LVL14:
 244               	/* epilogue start */
 245               		.loc 1 157 1 view .LVU39
 246 0002 0895      		ret
 247               		.cfi_endproc
 248               	.LFE111:
 250               		.section	.text.post_process_record_quantum,"ax",@progbits
 251               		.weak	post_process_record_quantum
 253               	post_process_record_quantum:
 254               	.LVL15:
 255               	.LFB112:
 158:tmk_core/common/action.c **** 
 159:tmk_core/common/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 256               		.loc 1 159 77 is_stmt 1 view -0
 257               		.cfi_startproc
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 0 */
 261               	.L__stack_usage = 0
 262               		.loc 1 159 78 view .LVU41
 263               	/* epilogue start */
 264               		.loc 1 159 1 is_stmt 0 view .LVU42
 265 0000 0895      		ret
 266               		.cfi_endproc
 267               	.LFE112:
 269               		.section	.text.process_record_tap_hint,"ax",@progbits
 270               	.global	process_record_tap_hint
 272               	process_record_tap_hint:
 273               	.LVL16:
 274               	.LFB113:
 160:tmk_core/common/action.c **** 
 161:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 162:tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:tmk_core/common/action.c ****  *
 164:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 165:tmk_core/common/action.c ****  */
 166:tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 275               		.loc 1 166 51 is_stmt 1 view -0
 276               		.cfi_startproc
 277               	/* prologue: function */
 278               	/* frame size = 0 */
 279               	/* stack size = 0 */
 280               	.L__stack_usage = 0
 167:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 281               		.loc 1 167 5 view .LVU44
 282               		.loc 1 167 23 is_stmt 0 view .LVU45
 283 0000 FC01      		movw r30,r24
 284 0002 8081      		ld r24,Z
 285 0004 9181      		ldd r25,Z+1
 286               	.LVL17:
 287               		.loc 1 167 23 view .LVU46
 288 0006 0E94 0000 		call layer_switch_get_action
 289               	.LVL18:
 168:tmk_core/common/action.c **** 
 169:tmk_core/common/action.c ****     switch (action.kind.id) {
 290               		.loc 1 169 5 is_stmt 1 view .LVU47
 291               		.loc 1 169 24 is_stmt 0 view .LVU48
 292 000a 9295      		swap r25
 293 000c 9F70      		andi r25,lo8(15)
 294               		.loc 1 169 5 view .LVU49
 295 000e 9630      		cpi r25,lo8(6)
 296 0010 01F4      		brne .L22
 170:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 172:tmk_core/common/action.c ****             switch (action.swap.code) {
 297               		.loc 1 172 13 is_stmt 1 view .LVU50
 298               	.LVL19:
 299               		.loc 1 172 13 is_stmt 0 view .LVU51
 300 0012 863F      		cpi r24,lo8(-10)
 301 0014 01F0      		breq .L22
 173:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 174:tmk_core/common/action.c ****                     break;
 175:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:tmk_core/common/action.c ****                 default:
 177:tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 302               		.loc 1 177 21 is_stmt 1 view .LVU52
 303 0016 8091 0000 		lds r24,swap_hands
 304               		.loc 1 177 21 is_stmt 0 view .LVU53
 305 001a 91E0      		ldi r25,lo8(1)
 306 001c 8927      		eor r24,r25
 307               		.loc 1 177 32 view .LVU54
 308 001e 8093 0000 		sts swap_hands,r24
 178:tmk_core/common/action.c ****                     swap_held  = true;
 309               		.loc 1 178 21 is_stmt 1 view .LVU55
 310               		.loc 1 178 32 is_stmt 0 view .LVU56
 311 0022 9093 0000 		sts swap_held,r25
 312               	.L22:
 313               	/* epilogue start */
 179:tmk_core/common/action.c ****             }
 180:tmk_core/common/action.c ****             break;
 181:tmk_core/common/action.c **** #    endif
 182:tmk_core/common/action.c ****     }
 183:tmk_core/common/action.c **** }
 314               		.loc 1 183 1 view .LVU57
 315 0026 0895      		ret
 316               		.cfi_endproc
 317               	.LFE113:
 319               		.section	.text.register_code,"ax",@progbits
 320               	.global	register_code
 322               	register_code:
 323               	.LVL20:
 324               	.LFB117:
 184:tmk_core/common/action.c **** #endif
 185:tmk_core/common/action.c **** 
 186:tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:tmk_core/common/action.c ****  *
 188:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 189:tmk_core/common/action.c ****  */
 190:tmk_core/common/action.c **** void process_record(keyrecord_t *record) {
 191:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 192:tmk_core/common/action.c ****         return;
 193:tmk_core/common/action.c ****     }
 194:tmk_core/common/action.c **** 
 195:tmk_core/common/action.c ****     if (!process_record_quantum(record)) {
 196:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 197:tmk_core/common/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:tmk_core/common/action.c ****         }
 200:tmk_core/common/action.c **** #endif
 201:tmk_core/common/action.c ****         return;
 202:tmk_core/common/action.c ****     }
 203:tmk_core/common/action.c **** 
 204:tmk_core/common/action.c ****     process_record_handler(record);
 205:tmk_core/common/action.c ****     post_process_record_quantum(record);
 206:tmk_core/common/action.c **** }
 207:tmk_core/common/action.c **** 
 208:tmk_core/common/action.c **** void process_record_handler(keyrecord_t *record) {
 209:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 210:tmk_core/common/action.c ****     dprint("ACTION: ");
 211:tmk_core/common/action.c ****     debug_action(action);
 212:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 213:tmk_core/common/action.c ****     dprint(" layer_state: ");
 214:tmk_core/common/action.c ****     layer_debug();
 215:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 216:tmk_core/common/action.c ****     default_layer_debug();
 217:tmk_core/common/action.c **** #endif
 218:tmk_core/common/action.c ****     dprintln();
 219:tmk_core/common/action.c **** 
 220:tmk_core/common/action.c ****     process_action(record, action);
 221:tmk_core/common/action.c **** }
 222:tmk_core/common/action.c **** 
 223:tmk_core/common/action.c **** /** \brief Take an action and processes it.
 224:tmk_core/common/action.c ****  *
 225:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 226:tmk_core/common/action.c ****  */
 227:tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action) {
 228:tmk_core/common/action.c ****     keyevent_t event = record->event;
 229:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 230:tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 231:tmk_core/common/action.c **** #endif
 232:tmk_core/common/action.c **** 
 233:tmk_core/common/action.c ****     if (event.pressed) {
 234:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 235:tmk_core/common/action.c ****         clear_weak_mods();
 236:tmk_core/common/action.c ****     }
 237:tmk_core/common/action.c **** 
 238:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 239:tmk_core/common/action.c ****     bool do_release_oneshot = false;
 240:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 241:tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 242:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 243:tmk_core/common/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 244:tmk_core/common/action.c **** #    endif
 245:tmk_core/common/action.c ****     ) {
 246:tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 247:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 248:tmk_core/common/action.c ****     }
 249:tmk_core/common/action.c **** #endif
 250:tmk_core/common/action.c **** 
 251:tmk_core/common/action.c ****     switch (action.kind.id) {
 252:tmk_core/common/action.c ****         /* Key and Mods */
 253:tmk_core/common/action.c ****         case ACT_LMODS:
 254:tmk_core/common/action.c ****         case ACT_RMODS: {
 255:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 256:tmk_core/common/action.c ****             if (event.pressed) {
 257:tmk_core/common/action.c ****                 if (mods) {
 258:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 259:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 260:tmk_core/common/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 261:tmk_core/common/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 262:tmk_core/common/action.c ****                         add_mods(mods);
 263:tmk_core/common/action.c ****                     } else {
 264:tmk_core/common/action.c ****                         add_weak_mods(mods);
 265:tmk_core/common/action.c ****                     }
 266:tmk_core/common/action.c ****                     send_keyboard_report();
 267:tmk_core/common/action.c ****                 }
 268:tmk_core/common/action.c ****                 register_code(action.key.code);
 269:tmk_core/common/action.c ****             } else {
 270:tmk_core/common/action.c ****                 unregister_code(action.key.code);
 271:tmk_core/common/action.c ****                 if (mods) {
 272:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 273:tmk_core/common/action.c ****                         del_mods(mods);
 274:tmk_core/common/action.c ****                     } else {
 275:tmk_core/common/action.c ****                         del_weak_mods(mods);
 276:tmk_core/common/action.c ****                     }
 277:tmk_core/common/action.c ****                     send_keyboard_report();
 278:tmk_core/common/action.c ****                 }
 279:tmk_core/common/action.c ****             }
 280:tmk_core/common/action.c ****         } break;
 281:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 282:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 283:tmk_core/common/action.c ****         case ACT_RMODS_TAP: {
 284:tmk_core/common/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 285:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 286:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 287:tmk_core/common/action.c ****                 case MODS_ONESHOT:
 288:tmk_core/common/action.c ****                     // Oneshot modifier
 289:tmk_core/common/action.c ****                     if (event.pressed) {
 290:tmk_core/common/action.c ****                         if (tap_count == 0) {
 291:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 292:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 293:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 294:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 295:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 296:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 297:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 298:tmk_core/common/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 299:tmk_core/common/action.c ****                             clear_oneshot_mods();
 300:tmk_core/common/action.c ****                             set_oneshot_locked_mods(mods);
 301:tmk_core/common/action.c ****                             register_mods(mods);
 302:tmk_core/common/action.c **** #        endif
 303:tmk_core/common/action.c ****                         } else {
 304:tmk_core/common/action.c ****                             register_mods(mods | get_oneshot_mods());
 305:tmk_core/common/action.c ****                         }
 306:tmk_core/common/action.c ****                     } else {
 307:tmk_core/common/action.c ****                         if (tap_count == 0) {
 308:tmk_core/common/action.c ****                             clear_oneshot_mods();
 309:tmk_core/common/action.c ****                             unregister_mods(mods);
 310:tmk_core/common/action.c ****                         } else if (tap_count == 1) {
 311:tmk_core/common/action.c ****                             // Retain Oneshot mods
 312:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 313:tmk_core/common/action.c ****                             if (mods & get_mods()) {
 314:tmk_core/common/action.c ****                                 clear_oneshot_locked_mods();
 315:tmk_core/common/action.c ****                                 clear_oneshot_mods();
 316:tmk_core/common/action.c ****                                 unregister_mods(mods);
 317:tmk_core/common/action.c ****                             }
 318:tmk_core/common/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 319:tmk_core/common/action.c ****                             // Toggle Oneshot Layer
 320:tmk_core/common/action.c **** #        endif
 321:tmk_core/common/action.c ****                         } else {
 322:tmk_core/common/action.c ****                             clear_oneshot_mods();
 323:tmk_core/common/action.c ****                             unregister_mods(mods);
 324:tmk_core/common/action.c ****                         }
 325:tmk_core/common/action.c ****                     }
 326:tmk_core/common/action.c ****                     break;
 327:tmk_core/common/action.c **** #    endif
 328:tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 329:tmk_core/common/action.c ****                     if (event.pressed) {
 330:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 331:tmk_core/common/action.c ****                             register_mods(mods);
 332:tmk_core/common/action.c ****                         }
 333:tmk_core/common/action.c ****                     } else {
 334:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 335:tmk_core/common/action.c ****                             unregister_mods(mods);
 336:tmk_core/common/action.c ****                         }
 337:tmk_core/common/action.c ****                     }
 338:tmk_core/common/action.c ****                     break;
 339:tmk_core/common/action.c ****                 default:
 340:tmk_core/common/action.c ****                     if (event.pressed) {
 341:tmk_core/common/action.c ****                         if (tap_count > 0) {
 342:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 343:tmk_core/common/action.c ****                             if (
 344:tmk_core/common/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 345:tmk_core/common/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 346:tmk_core/common/action.c **** #        endif
 347:tmk_core/common/action.c ****                                 record->tap.interrupted) {
 348:tmk_core/common/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 349:tmk_core/common/action.c ****                                 // ad hoc: set 0 to cancel tap
 350:tmk_core/common/action.c ****                                 record->tap.count = 0;
 351:tmk_core/common/action.c ****                                 register_mods(mods);
 352:tmk_core/common/action.c ****                             } else
 353:tmk_core/common/action.c **** #    endif
 354:tmk_core/common/action.c ****                             {
 355:tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 356:tmk_core/common/action.c ****                                 register_code(action.key.code);
 357:tmk_core/common/action.c ****                             }
 358:tmk_core/common/action.c ****                         } else {
 359:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 360:tmk_core/common/action.c ****                             register_mods(mods);
 361:tmk_core/common/action.c ****                         }
 362:tmk_core/common/action.c ****                     } else {
 363:tmk_core/common/action.c ****                         if (tap_count > 0) {
 364:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 365:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 366:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 367:tmk_core/common/action.c ****                             } else {
 368:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 369:tmk_core/common/action.c ****                             }
 370:tmk_core/common/action.c ****                             unregister_code(action.key.code);
 371:tmk_core/common/action.c ****                         } else {
 372:tmk_core/common/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 373:tmk_core/common/action.c ****                             unregister_mods(mods);
 374:tmk_core/common/action.c ****                         }
 375:tmk_core/common/action.c ****                     }
 376:tmk_core/common/action.c ****                     break;
 377:tmk_core/common/action.c ****             }
 378:tmk_core/common/action.c ****         } break;
 379:tmk_core/common/action.c **** #endif
 380:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 381:tmk_core/common/action.c ****         /* other HID usage */
 382:tmk_core/common/action.c ****         case ACT_USAGE:
 383:tmk_core/common/action.c ****             switch (action.usage.page) {
 384:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 385:tmk_core/common/action.c ****                     if (event.pressed) {
 386:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 387:tmk_core/common/action.c ****                     } else {
 388:tmk_core/common/action.c ****                         host_system_send(0);
 389:tmk_core/common/action.c ****                     }
 390:tmk_core/common/action.c ****                     break;
 391:tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 392:tmk_core/common/action.c ****                     if (event.pressed) {
 393:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 394:tmk_core/common/action.c ****                     } else {
 395:tmk_core/common/action.c ****                         host_consumer_send(0);
 396:tmk_core/common/action.c ****                     }
 397:tmk_core/common/action.c ****                     break;
 398:tmk_core/common/action.c ****             }
 399:tmk_core/common/action.c ****             break;
 400:tmk_core/common/action.c **** #endif
 401:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 402:tmk_core/common/action.c ****         /* Mouse key */
 403:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 404:tmk_core/common/action.c ****             if (event.pressed) {
 405:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 406:tmk_core/common/action.c ****                 switch (action.key.code) {
 407:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 408:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 409:tmk_core/common/action.c ****                         tp_buttons |= (1 << 0);
 410:tmk_core/common/action.c ****                         break;
 411:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 412:tmk_core/common/action.c ****                         tp_buttons |= (1 << 1);
 413:tmk_core/common/action.c ****                         break;
 414:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 415:tmk_core/common/action.c ****                         tp_buttons |= (1 << 2);
 416:tmk_core/common/action.c ****                         break;
 417:tmk_core/common/action.c **** #    endif
 418:tmk_core/common/action.c ****                     default:
 419:tmk_core/common/action.c ****                         mousekey_send();
 420:tmk_core/common/action.c ****                         break;
 421:tmk_core/common/action.c ****                 }
 422:tmk_core/common/action.c ****             } else {
 423:tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 424:tmk_core/common/action.c ****                 switch (action.key.code) {
 425:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 426:tmk_core/common/action.c ****                     case KC_MS_BTN1:
 427:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 0);
 428:tmk_core/common/action.c ****                         break;
 429:tmk_core/common/action.c ****                     case KC_MS_BTN2:
 430:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 1);
 431:tmk_core/common/action.c ****                         break;
 432:tmk_core/common/action.c ****                     case KC_MS_BTN3:
 433:tmk_core/common/action.c ****                         tp_buttons &= ~(1 << 2);
 434:tmk_core/common/action.c ****                         break;
 435:tmk_core/common/action.c **** #    endif
 436:tmk_core/common/action.c ****                     default:
 437:tmk_core/common/action.c ****                         mousekey_send();
 438:tmk_core/common/action.c ****                         break;
 439:tmk_core/common/action.c ****                 }
 440:tmk_core/common/action.c ****             }
 441:tmk_core/common/action.c ****             break;
 442:tmk_core/common/action.c **** #endif
 443:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 444:tmk_core/common/action.c ****         case ACT_LAYER:
 445:tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 446:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 447:tmk_core/common/action.c ****                 if (!event.pressed) {
 448:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 449:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 450:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 451:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 452:tmk_core/common/action.c ****                         case OP_BIT_AND:
 453:tmk_core/common/action.c ****                             default_layer_and(bits | mask);
 454:tmk_core/common/action.c ****                             break;
 455:tmk_core/common/action.c ****                         case OP_BIT_OR:
 456:tmk_core/common/action.c ****                             default_layer_or(bits | mask);
 457:tmk_core/common/action.c ****                             break;
 458:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 459:tmk_core/common/action.c ****                             default_layer_xor(bits | mask);
 460:tmk_core/common/action.c ****                             break;
 461:tmk_core/common/action.c ****                         case OP_BIT_SET:
 462:tmk_core/common/action.c ****                             default_layer_set(bits | mask);
 463:tmk_core/common/action.c ****                             break;
 464:tmk_core/common/action.c ****                     }
 465:tmk_core/common/action.c ****                 }
 466:tmk_core/common/action.c ****             } else {
 467:tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 468:tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 469:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 470:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 471:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 472:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 473:tmk_core/common/action.c ****                         case OP_BIT_AND:
 474:tmk_core/common/action.c ****                             layer_and(bits | mask);
 475:tmk_core/common/action.c ****                             break;
 476:tmk_core/common/action.c ****                         case OP_BIT_OR:
 477:tmk_core/common/action.c ****                             layer_or(bits | mask);
 478:tmk_core/common/action.c ****                             break;
 479:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 480:tmk_core/common/action.c ****                             layer_xor(bits | mask);
 481:tmk_core/common/action.c ****                             break;
 482:tmk_core/common/action.c ****                         case OP_BIT_SET:
 483:tmk_core/common/action.c ****                             layer_state_set(bits | mask);
 484:tmk_core/common/action.c ****                             break;
 485:tmk_core/common/action.c ****                     }
 486:tmk_core/common/action.c ****                 }
 487:tmk_core/common/action.c ****             }
 488:tmk_core/common/action.c ****             break;
 489:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 490:tmk_core/common/action.c ****             if (event.pressed) {
 491:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 492:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 493:tmk_core/common/action.c ****             } else {
 494:tmk_core/common/action.c ****                 unregister_mods(action.layer_mods.mods);
 495:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 496:tmk_core/common/action.c ****             }
 497:tmk_core/common/action.c ****             break;
 498:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 499:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 500:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 501:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 502:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 503:tmk_core/common/action.c ****                     /* tap toggle */
 504:tmk_core/common/action.c ****                     if (event.pressed) {
 505:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 506:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 507:tmk_core/common/action.c ****                         }
 508:tmk_core/common/action.c ****                     } else {
 509:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 510:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 511:tmk_core/common/action.c ****                         }
 512:tmk_core/common/action.c ****                     }
 513:tmk_core/common/action.c ****                     break;
 514:tmk_core/common/action.c ****                 case OP_ON_OFF:
 515:tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 516:tmk_core/common/action.c ****                     break;
 517:tmk_core/common/action.c ****                 case OP_OFF_ON:
 518:tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 519:tmk_core/common/action.c ****                     break;
 520:tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 521:tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 522:tmk_core/common/action.c ****                     break;
 523:tmk_core/common/action.c **** #        ifndef NO_ACTION_ONESHOT
 524:tmk_core/common/action.c ****                 case OP_ONESHOT:
 525:tmk_core/common/action.c ****                     // Oneshot modifier
 526:tmk_core/common/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 527:tmk_core/common/action.c ****                     do_release_oneshot = false;
 528:tmk_core/common/action.c ****                     if (event.pressed) {
 529:tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 530:tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 531:tmk_core/common/action.c ****                             reset_oneshot_layer();
 532:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 533:tmk_core/common/action.c ****                             break;
 534:tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 535:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 536:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 537:tmk_core/common/action.c ****                         }
 538:tmk_core/common/action.c ****                     } else {
 539:tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 540:tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 541:tmk_core/common/action.c ****                             reset_oneshot_layer();
 542:tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 543:tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 544:tmk_core/common/action.c ****                         } else {
 545:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 546:tmk_core/common/action.c ****                         }
 547:tmk_core/common/action.c ****                     }
 548:tmk_core/common/action.c **** #            else
 549:tmk_core/common/action.c ****                     if (event.pressed) {
 550:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 551:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 552:tmk_core/common/action.c ****                     } else {
 553:tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 554:tmk_core/common/action.c ****                         if (tap_count > 1) {
 555:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 556:tmk_core/common/action.c ****                         }
 557:tmk_core/common/action.c ****                     }
 558:tmk_core/common/action.c **** #            endif
 559:tmk_core/common/action.c ****                     break;
 560:tmk_core/common/action.c **** #        endif
 561:tmk_core/common/action.c ****                 default:
 562:tmk_core/common/action.c ****                     /* tap key */
 563:tmk_core/common/action.c ****                     if (event.pressed) {
 564:tmk_core/common/action.c ****                         if (tap_count > 0) {
 565:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 566:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 567:tmk_core/common/action.c ****                         } else {
 568:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 569:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 570:tmk_core/common/action.c ****                         }
 571:tmk_core/common/action.c ****                     } else {
 572:tmk_core/common/action.c ****                         if (tap_count > 0) {
 573:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 574:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 575:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 576:tmk_core/common/action.c ****                             } else {
 577:tmk_core/common/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 578:tmk_core/common/action.c ****                             }
 579:tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 580:tmk_core/common/action.c ****                         } else {
 581:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 582:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 583:tmk_core/common/action.c ****                         }
 584:tmk_core/common/action.c ****                     }
 585:tmk_core/common/action.c ****                     break;
 586:tmk_core/common/action.c ****             }
 587:tmk_core/common/action.c ****             break;
 588:tmk_core/common/action.c **** #    endif
 589:tmk_core/common/action.c **** #endif
 590:tmk_core/common/action.c ****             /* Extentions */
 591:tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 592:tmk_core/common/action.c ****         case ACT_MACRO:
 593:tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 594:tmk_core/common/action.c ****             break;
 595:tmk_core/common/action.c **** #endif
 596:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 597:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 598:tmk_core/common/action.c ****             switch (action.swap.code) {
 599:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 600:tmk_core/common/action.c ****                     if (event.pressed) {
 601:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 602:tmk_core/common/action.c ****                     }
 603:tmk_core/common/action.c ****                     break;
 604:tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 605:tmk_core/common/action.c ****                     swap_hands = event.pressed;
 606:tmk_core/common/action.c ****                     break;
 607:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 608:tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 609:tmk_core/common/action.c ****                     break;
 610:tmk_core/common/action.c ****                 case OP_SH_ON:
 611:tmk_core/common/action.c ****                     if (!event.pressed) {
 612:tmk_core/common/action.c ****                         swap_hands = true;
 613:tmk_core/common/action.c ****                     }
 614:tmk_core/common/action.c ****                     break;
 615:tmk_core/common/action.c ****                 case OP_SH_OFF:
 616:tmk_core/common/action.c ****                     if (!event.pressed) {
 617:tmk_core/common/action.c ****                         swap_hands = false;
 618:tmk_core/common/action.c ****                     }
 619:tmk_core/common/action.c ****                     break;
 620:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 621:tmk_core/common/action.c ****                 case OP_SH_ONESHOT:
 622:tmk_core/common/action.c ****                     if (event.pressed) {
 623:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 624:tmk_core/common/action.c ****                     } else {
 625:tmk_core/common/action.c ****                         release_oneshot_swaphands();
 626:tmk_core/common/action.c ****                     }
 627:tmk_core/common/action.c ****                     break;
 628:tmk_core/common/action.c **** #    endif
 629:tmk_core/common/action.c **** 
 630:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 631:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 632:tmk_core/common/action.c ****                     /* tap toggle */
 633:tmk_core/common/action.c **** 
 634:tmk_core/common/action.c ****                     if (event.pressed) {
 635:tmk_core/common/action.c ****                         if (swap_held) {
 636:tmk_core/common/action.c ****                             swap_held = false;
 637:tmk_core/common/action.c ****                         } else {
 638:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 639:tmk_core/common/action.c ****                         }
 640:tmk_core/common/action.c ****                     } else {
 641:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 642:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 643:tmk_core/common/action.c ****                         }
 644:tmk_core/common/action.c ****                     }
 645:tmk_core/common/action.c ****                     break;
 646:tmk_core/common/action.c ****                 default:
 647:tmk_core/common/action.c ****                     /* tap key */
 648:tmk_core/common/action.c ****                     if (tap_count > 0) {
 649:tmk_core/common/action.c ****                         if (swap_held) {
 650:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 651:tmk_core/common/action.c ****                             swap_held  = false;
 652:tmk_core/common/action.c ****                         }
 653:tmk_core/common/action.c ****                         if (event.pressed) {
 654:tmk_core/common/action.c ****                             register_code(action.swap.code);
 655:tmk_core/common/action.c ****                         } else {
 656:tmk_core/common/action.c ****                             wait_ms(TAP_CODE_DELAY);
 657:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 658:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 659:tmk_core/common/action.c ****                         }
 660:tmk_core/common/action.c ****                     } else {
 661:tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 662:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 663:tmk_core/common/action.c ****                             swap_held  = false;
 664:tmk_core/common/action.c ****                         }
 665:tmk_core/common/action.c ****                     }
 666:tmk_core/common/action.c **** #    endif
 667:tmk_core/common/action.c ****             }
 668:tmk_core/common/action.c **** #endif
 669:tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 670:tmk_core/common/action.c ****         case ACT_FUNCTION:
 671:tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 672:tmk_core/common/action.c ****             break;
 673:tmk_core/common/action.c **** #endif
 674:tmk_core/common/action.c ****         default:
 675:tmk_core/common/action.c ****             break;
 676:tmk_core/common/action.c ****     }
 677:tmk_core/common/action.c **** 
 678:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 679:tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 680:tmk_core/common/action.c ****     switch (action.kind.id) {
 681:tmk_core/common/action.c ****         case ACT_LAYER:
 682:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
 683:tmk_core/common/action.c **** #    ifndef NO_ACTION_TAPPING
 684:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 685:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 686:tmk_core/common/action.c **** #    endif
 687:tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 688:tmk_core/common/action.c ****             break;
 689:tmk_core/common/action.c ****         default:
 690:tmk_core/common/action.c ****             break;
 691:tmk_core/common/action.c ****     }
 692:tmk_core/common/action.c **** #endif
 693:tmk_core/common/action.c **** 
 694:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 695:tmk_core/common/action.c **** #    ifdef RETRO_TAPPING
 696:tmk_core/common/action.c ****     if (!is_tap_action(action)) {
 697:tmk_core/common/action.c ****         retro_tapping_counter = 0;
 698:tmk_core/common/action.c ****     } else {
 699:tmk_core/common/action.c ****         if (event.pressed) {
 700:tmk_core/common/action.c ****             if (tap_count > 0) {
 701:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 702:tmk_core/common/action.c ****             } else {
 703:tmk_core/common/action.c ****             }
 704:tmk_core/common/action.c ****         } else {
 705:tmk_core/common/action.c ****             if (tap_count > 0) {
 706:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 707:tmk_core/common/action.c ****             } else {
 708:tmk_core/common/action.c ****                 if (retro_tapping_counter == 2) {
 709:tmk_core/common/action.c ****                     tap_code(action.layer_tap.code);
 710:tmk_core/common/action.c ****                 }
 711:tmk_core/common/action.c ****                 retro_tapping_counter = 0;
 712:tmk_core/common/action.c ****             }
 713:tmk_core/common/action.c ****         }
 714:tmk_core/common/action.c ****     }
 715:tmk_core/common/action.c **** #    endif
 716:tmk_core/common/action.c **** #endif
 717:tmk_core/common/action.c **** 
 718:tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 719:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 720:tmk_core/common/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 721:tmk_core/common/action.c ****         use_oneshot_swaphands();
 722:tmk_core/common/action.c ****     }
 723:tmk_core/common/action.c **** #    endif
 724:tmk_core/common/action.c **** #endif
 725:tmk_core/common/action.c **** 
 726:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 727:tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 728:tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 729:tmk_core/common/action.c ****      */
 730:tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 731:tmk_core/common/action.c ****         record->event.pressed = false;
 732:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 733:tmk_core/common/action.c ****         process_record(record);
 734:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 735:tmk_core/common/action.c ****     }
 736:tmk_core/common/action.c **** #endif
 737:tmk_core/common/action.c **** }
 738:tmk_core/common/action.c **** 
 739:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 740:tmk_core/common/action.c ****  *
 741:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 742:tmk_core/common/action.c ****  */
 743:tmk_core/common/action.c **** void register_code(uint8_t code) {
 325               		.loc 1 743 34 is_stmt 1 view -0
 326               		.cfi_startproc
 327               		.loc 1 743 34 is_stmt 0 view .LVU59
 328 0000 CF93      		push r28
 329               	.LCFI6:
 330               		.cfi_def_cfa_offset 3
 331               		.cfi_offset 28, -2
 332               	/* prologue: function */
 333               	/* frame size = 0 */
 334               	/* stack size = 1 */
 335               	.L__stack_usage = 1
 336 0002 C82F      		mov r28,r24
 744:tmk_core/common/action.c ****     if (code == KC_NO) {
 337               		.loc 1 744 5 is_stmt 1 view .LVU60
 338               		.loc 1 744 8 is_stmt 0 view .LVU61
 339 0004 8823      		tst r24
 340 0006 01F4      		brne .+2
 341 0008 00C0      		rjmp .L27
 745:tmk_core/common/action.c ****         return;
 746:tmk_core/common/action.c ****     }
 747:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 748:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 342               		.loc 1 748 10 is_stmt 1 view .LVU62
 343               		.loc 1 748 13 is_stmt 0 view .LVU63
 344 000a 8238      		cpi r24,lo8(-126)
 345 000c 01F4      		brne .L30
 749:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 750:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 751:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 346               		.loc 1 751 9 is_stmt 1 view .LVU64
 347               		.loc 1 751 13 is_stmt 0 view .LVU65
 348 000e 0E94 0000 		call host_keyboard_leds
 349               	.LVL21:
 350               		.loc 1 751 12 view .LVU66
 351 0012 81FD      		sbrc r24,1
 352 0014 00C0      		rjmp .L27
 752:tmk_core/common/action.c **** #    endif
 753:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 353               		.loc 1 753 9 is_stmt 1 view .LVU67
 354 0016 89E3      		ldi r24,lo8(57)
 355 0018 0E94 0000 		call add_key
 356               	.LVL22:
 754:tmk_core/common/action.c ****         send_keyboard_report();
 357               		.loc 1 754 9 view .LVU68
 358 001c 0E94 0000 		call send_keyboard_report
 359               	.LVL23:
 755:tmk_core/common/action.c ****         wait_ms(100);
 360               		.loc 1 755 9 view .LVU69
 361               	.LBB40:
 362               	.LBI40:
 363               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 364               		.loc 3 166 1 view .LVU70
 365               	.LBB41:
 167:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	double __tmp ;
 366               		.loc 3 168 2 view .LVU71
 169:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 367               		.loc 3 172 2 view .LVU72
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 368               		.loc 3 173 2 view .LVU73
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 369               		.loc 3 174 2 view .LVU74
 175:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 370               		.loc 3 184 3 view .LVU75
 185:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 371               		.loc 3 187 2 view .LVU76
 372 0020 2FEF      		ldi r18,lo8(319999)
 373 0022 81EE      		ldi r24,hi8(319999)
 374 0024 94E0      		ldi r25,hlo8(319999)
 375 0026 2150      	1:	subi r18,1
 376 0028 8040      		sbci r24,0
 377 002a 9040      		sbci r25,0
 378 002c 01F4      		brne 1b
 379 002e 00C0      		rjmp .
 380 0030 0000      		nop
 381               	.LVL24:
 382               		.loc 3 187 2 is_stmt 0 view .LVU77
 383               	.LBE41:
 384               	.LBE40:
 756:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 385               		.loc 1 756 9 is_stmt 1 view .LVU78
 386 0032 89E3      		ldi r24,lo8(57)
 387               	.L42:
 757:tmk_core/common/action.c ****         send_keyboard_report();
 758:tmk_core/common/action.c ****     }
 759:tmk_core/common/action.c **** 
 760:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 761:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 762:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 763:tmk_core/common/action.c **** #    endif
 764:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 765:tmk_core/common/action.c ****         send_keyboard_report();
 766:tmk_core/common/action.c ****         wait_ms(100);
 767:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 388               		.loc 1 767 9 is_stmt 0 view .LVU79
 389 0034 0E94 0000 		call del_key
 390               	.LVL25:
 391               	.L43:
 768:tmk_core/common/action.c ****         send_keyboard_report();
 392               		.loc 1 768 9 is_stmt 1 view .LVU80
 393               	/* epilogue start */
 769:tmk_core/common/action.c ****     }
 770:tmk_core/common/action.c **** 
 771:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 772:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 773:tmk_core/common/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 774:tmk_core/common/action.c **** #    endif
 775:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 776:tmk_core/common/action.c ****         send_keyboard_report();
 777:tmk_core/common/action.c ****         wait_ms(100);
 778:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 779:tmk_core/common/action.c ****         send_keyboard_report();
 780:tmk_core/common/action.c ****     }
 781:tmk_core/common/action.c **** #endif
 782:tmk_core/common/action.c **** 
 783:tmk_core/common/action.c ****     else if
 784:tmk_core/common/action.c ****         IS_KEY(code) {
 785:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 786:tmk_core/common/action.c ****             if (command_proc(code)) return;
 787:tmk_core/common/action.c **** 
 788:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 789:tmk_core/common/action.c **** /* TODO: remove
 790:tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 791:tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 792:tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 793:tmk_core/common/action.c **** 
 794:tmk_core/common/action.c ****             add_key(code);
 795:tmk_core/common/action.c ****             send_keyboard_report();
 796:tmk_core/common/action.c **** 
 797:tmk_core/common/action.c ****             set_mods(tmp_mods);
 798:tmk_core/common/action.c ****             send_keyboard_report();
 799:tmk_core/common/action.c ****             oneshot_cancel();
 800:tmk_core/common/action.c ****         } else
 801:tmk_core/common/action.c **** */
 802:tmk_core/common/action.c **** #endif
 803:tmk_core/common/action.c ****             {
 804:tmk_core/common/action.c ****                 // Force a new key press if the key is already pressed
 805:tmk_core/common/action.c ****                 // without this, keys with the same keycode, but different
 806:tmk_core/common/action.c ****                 // modifiers will be reported incorrectly, see issue #1708
 807:tmk_core/common/action.c ****                 if (is_key_pressed(keyboard_report, code)) {
 808:tmk_core/common/action.c ****                     del_key(code);
 809:tmk_core/common/action.c ****                     send_keyboard_report();
 810:tmk_core/common/action.c ****                 }
 811:tmk_core/common/action.c ****                 add_key(code);
 812:tmk_core/common/action.c ****                 send_keyboard_report();
 813:tmk_core/common/action.c ****             }
 814:tmk_core/common/action.c ****         }
 815:tmk_core/common/action.c ****     else if
 816:tmk_core/common/action.c ****         IS_MOD(code) {
 817:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 818:tmk_core/common/action.c ****             send_keyboard_report();
 819:tmk_core/common/action.c ****         }
 820:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 821:tmk_core/common/action.c ****     else if
 822:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 823:tmk_core/common/action.c ****     else if
 824:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 825:tmk_core/common/action.c **** #endif
 826:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 827:tmk_core/common/action.c ****     else if
 828:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 829:tmk_core/common/action.c ****             mousekey_on(code);
 830:tmk_core/common/action.c ****             mousekey_send();
 831:tmk_core/common/action.c ****         }
 832:tmk_core/common/action.c **** #endif
 833:tmk_core/common/action.c **** }
 394               		.loc 1 833 1 is_stmt 0 view .LVU81
 395 0038 CF91      		pop r28
 768:tmk_core/common/action.c ****         send_keyboard_report();
 396               		.loc 1 768 9 view .LVU82
 397 003a 0C94 0000 		jmp send_keyboard_report
 398               	.LVL26:
 399               	.L30:
 760:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 400               		.loc 1 760 10 is_stmt 1 view .LVU83
 760:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 401               		.loc 1 760 13 is_stmt 0 view .LVU84
 402 003e 8338      		cpi r24,lo8(-125)
 403 0040 01F4      		brne .L32
 762:tmk_core/common/action.c **** #    endif
 404               		.loc 1 762 9 is_stmt 1 view .LVU85
 762:tmk_core/common/action.c **** #    endif
 405               		.loc 1 762 13 is_stmt 0 view .LVU86
 406 0042 0E94 0000 		call host_keyboard_leds
 407               	.LVL27:
 762:tmk_core/common/action.c **** #    endif
 408               		.loc 1 762 12 view .LVU87
 409 0046 80FD      		sbrc r24,0
 410 0048 00C0      		rjmp .L27
 764:tmk_core/common/action.c ****         send_keyboard_report();
 411               		.loc 1 764 9 is_stmt 1 view .LVU88
 412 004a 83E5      		ldi r24,lo8(83)
 413 004c 0E94 0000 		call add_key
 414               	.LVL28:
 765:tmk_core/common/action.c ****         wait_ms(100);
 415               		.loc 1 765 9 view .LVU89
 416 0050 0E94 0000 		call send_keyboard_report
 417               	.LVL29:
 766:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 418               		.loc 1 766 9 view .LVU90
 419               	.LBB42:
 420               	.LBI42:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 421               		.loc 3 166 1 view .LVU91
 422               	.LBB43:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 423               		.loc 3 168 2 view .LVU92
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 424               		.loc 3 172 2 view .LVU93
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 425               		.loc 3 173 2 view .LVU94
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 426               		.loc 3 174 2 view .LVU95
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 427               		.loc 3 184 3 view .LVU96
 428               		.loc 3 187 2 view .LVU97
 429 0054 2FEF      		ldi r18,lo8(319999)
 430 0056 81EE      		ldi r24,hi8(319999)
 431 0058 94E0      		ldi r25,hlo8(319999)
 432 005a 2150      	1:	subi r18,1
 433 005c 8040      		sbci r24,0
 434 005e 9040      		sbci r25,0
 435 0060 01F4      		brne 1b
 436 0062 00C0      		rjmp .
 437 0064 0000      		nop
 438               	.LVL30:
 439               		.loc 3 187 2 is_stmt 0 view .LVU98
 440               	.LBE43:
 441               	.LBE42:
 767:tmk_core/common/action.c ****         send_keyboard_report();
 442               		.loc 1 767 9 is_stmt 1 view .LVU99
 443 0066 83E5      		ldi r24,lo8(83)
 444 0068 00C0      		rjmp .L42
 445               	.LVL31:
 446               	.L32:
 771:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 447               		.loc 1 771 10 view .LVU100
 771:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 448               		.loc 1 771 13 is_stmt 0 view .LVU101
 449 006a 8438      		cpi r24,lo8(-124)
 450 006c 01F4      		brne .L33
 773:tmk_core/common/action.c **** #    endif
 451               		.loc 1 773 9 is_stmt 1 view .LVU102
 773:tmk_core/common/action.c **** #    endif
 452               		.loc 1 773 13 is_stmt 0 view .LVU103
 453 006e 0E94 0000 		call host_keyboard_leds
 454               	.LVL32:
 773:tmk_core/common/action.c **** #    endif
 455               		.loc 1 773 12 view .LVU104
 456 0072 82FD      		sbrc r24,2
 457 0074 00C0      		rjmp .L27
 775:tmk_core/common/action.c ****         send_keyboard_report();
 458               		.loc 1 775 9 is_stmt 1 view .LVU105
 459 0076 87E4      		ldi r24,lo8(71)
 460 0078 0E94 0000 		call add_key
 461               	.LVL33:
 776:tmk_core/common/action.c ****         wait_ms(100);
 462               		.loc 1 776 9 view .LVU106
 463 007c 0E94 0000 		call send_keyboard_report
 464               	.LVL34:
 777:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 465               		.loc 1 777 9 view .LVU107
 466               	.LBB44:
 467               	.LBI44:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 468               		.loc 3 166 1 view .LVU108
 469               	.LBB45:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 470               		.loc 3 168 2 view .LVU109
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 471               		.loc 3 172 2 view .LVU110
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 472               		.loc 3 173 2 view .LVU111
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 473               		.loc 3 174 2 view .LVU112
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 474               		.loc 3 184 3 view .LVU113
 475               		.loc 3 187 2 view .LVU114
 476 0080 2FEF      		ldi r18,lo8(319999)
 477 0082 81EE      		ldi r24,hi8(319999)
 478 0084 94E0      		ldi r25,hlo8(319999)
 479 0086 2150      	1:	subi r18,1
 480 0088 8040      		sbci r24,0
 481 008a 9040      		sbci r25,0
 482 008c 01F4      		brne 1b
 483 008e 00C0      		rjmp .
 484 0090 0000      		nop
 485               	.LVL35:
 486               		.loc 3 187 2 is_stmt 0 view .LVU115
 487               	.LBE45:
 488               	.LBE44:
 778:tmk_core/common/action.c ****         send_keyboard_report();
 489               		.loc 1 778 9 is_stmt 1 view .LVU116
 490 0092 87E4      		ldi r24,lo8(71)
 491 0094 00C0      		rjmp .L42
 492               	.LVL36:
 493               	.L33:
 783:tmk_core/common/action.c ****         IS_KEY(code) {
 494               		.loc 1 783 10 view .LVU117
 784:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 495               		.loc 1 784 9 is_stmt 0 view .LVU118
 496 0096 8CEF      		ldi r24,lo8(-4)
 497               	.LVL37:
 784:tmk_core/common/action.c ****             // TODO: should push command_proc out of this block?
 498               		.loc 1 784 9 view .LVU119
 499 0098 8C0F      		add r24,r28
 500 009a 813A      		cpi r24,lo8(-95)
 501 009c 00F4      		brsh .L34
 786:tmk_core/common/action.c **** 
 502               		.loc 1 786 13 is_stmt 1 view .LVU120
 786:tmk_core/common/action.c **** 
 503               		.loc 1 786 17 is_stmt 0 view .LVU121
 504 009e 8C2F      		mov r24,r28
 505 00a0 0E94 0000 		call command_proc
 506               	.LVL38:
 786:tmk_core/common/action.c **** 
 507               		.loc 1 786 16 view .LVU122
 508 00a4 8111      		cpse r24,__zero_reg__
 509 00a6 00C0      		rjmp .L27
 807:tmk_core/common/action.c ****                     del_key(code);
 510               		.loc 1 807 17 is_stmt 1 view .LVU123
 807:tmk_core/common/action.c ****                     del_key(code);
 511               		.loc 1 807 21 is_stmt 0 view .LVU124
 512 00a8 6C2F      		mov r22,r28
 513 00aa 8091 0000 		lds r24,keyboard_report
 514 00ae 9091 0000 		lds r25,keyboard_report+1
 515 00b2 0E94 0000 		call is_key_pressed
 516               	.LVL39:
 807:tmk_core/common/action.c ****                     del_key(code);
 517               		.loc 1 807 20 view .LVU125
 518 00b6 8823      		tst r24
 519 00b8 01F0      		breq .L35
 808:tmk_core/common/action.c ****                     send_keyboard_report();
 520               		.loc 1 808 21 is_stmt 1 view .LVU126
 521 00ba 8C2F      		mov r24,r28
 522 00bc 0E94 0000 		call del_key
 523               	.LVL40:
 809:tmk_core/common/action.c ****                 }
 524               		.loc 1 809 21 view .LVU127
 525 00c0 0E94 0000 		call send_keyboard_report
 526               	.LVL41:
 527               	.L35:
 811:tmk_core/common/action.c ****                 send_keyboard_report();
 528               		.loc 1 811 17 view .LVU128
 529 00c4 8C2F      		mov r24,r28
 530 00c6 0E94 0000 		call add_key
 531               	.LVL42:
 812:tmk_core/common/action.c ****             }
 532               		.loc 1 812 17 view .LVU129
 533 00ca 00C0      		rjmp .L43
 534               	.L34:
 815:tmk_core/common/action.c ****         IS_MOD(code) {
 535               		.loc 1 815 10 view .LVU130
 816:tmk_core/common/action.c ****             add_mods(MOD_BIT(code));
 536               		.loc 1 816 9 is_stmt 0 view .LVU131
 537 00cc 80E2      		ldi r24,lo8(32)
 538 00ce 8C0F      		add r24,r28
 539 00d0 8830      		cpi r24,lo8(8)
 540 00d2 00F4      		brsh .L36
 817:tmk_core/common/action.c ****             send_keyboard_report();
 541               		.loc 1 817 13 is_stmt 1 view .LVU132
 817:tmk_core/common/action.c ****             send_keyboard_report();
 542               		.loc 1 817 22 is_stmt 0 view .LVU133
 543 00d4 C770      		andi r28,lo8(7)
 544               	.LVL43:
 817:tmk_core/common/action.c ****             send_keyboard_report();
 545               		.loc 1 817 13 view .LVU134
 546 00d6 81E0      		ldi r24,lo8(1)
 547 00d8 00C0      		rjmp 2f
 548               		1:
 549 00da 880F      		lsl r24
 550               		2:
 551 00dc CA95      		dec r28
 552 00de 02F4      		brpl 1b
 553 00e0 0E94 0000 		call add_mods
 554               	.LVL44:
 818:tmk_core/common/action.c ****         }
 555               		.loc 1 818 13 is_stmt 1 view .LVU135
 556 00e4 00C0      		rjmp .L43
 557               	.LVL45:
 558               	.L36:
 821:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(KEYCODE2SYSTEM(code)); }
 559               		.loc 1 821 10 view .LVU136
 822:tmk_core/common/action.c ****     else if
 560               		.loc 1 822 9 is_stmt 0 view .LVU137
 561 00e6 EBE5      		ldi r30,lo8(91)
 562 00e8 EC0F      		add r30,r28
 563 00ea E330      		cpi r30,lo8(3)
 564 00ec 00F4      		brsh .L37
 822:tmk_core/common/action.c ****     else if
 565               		.loc 1 822 27 is_stmt 1 view .LVU138
 566               	.LVL46:
 567               	.LBB46:
 568               	.LBI46:
 569               		.file 4 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK
  34:tmk_core/common/report.h **** };
  35:tmk_core/common/report.h **** 
  36:tmk_core/common/report.h **** /* Mouse buttons */
  37:tmk_core/common/report.h **** enum mouse_buttons {
  38:tmk_core/common/report.h ****     MOUSE_BTN1 = (1 << 0),
  39:tmk_core/common/report.h ****     MOUSE_BTN2 = (1 << 1),
  40:tmk_core/common/report.h ****     MOUSE_BTN3 = (1 << 2),
  41:tmk_core/common/report.h ****     MOUSE_BTN4 = (1 << 3),
  42:tmk_core/common/report.h ****     MOUSE_BTN5 = (1 << 4)
  43:tmk_core/common/report.h **** };
  44:tmk_core/common/report.h **** 
  45:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  46:tmk_core/common/report.h ****  *
  47:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  48:tmk_core/common/report.h ****  */
  49:tmk_core/common/report.h **** enum consumer_usages {
  50:tmk_core/common/report.h ****     // 15.5 Display Controls
  51:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  52:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  53:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  54:tmk_core/common/report.h ****     // 15.7 Transport Controls
  55:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  56:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  57:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  58:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  59:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  60:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  61:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  62:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  63:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  64:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  65:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  66:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  67:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  68:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  69:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  70:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  71:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  72:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  73:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  74:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  75:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  76:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  77:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  78:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  79:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  80:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
  81:tmk_core/common/report.h ****     AC_HOME                = 0x223,
  82:tmk_core/common/report.h ****     AC_BACK                = 0x224,
  83:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
  84:tmk_core/common/report.h ****     AC_STOP                = 0x226,
  85:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
  86:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
  87:tmk_core/common/report.h **** };
  88:tmk_core/common/report.h **** 
  89:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
  90:tmk_core/common/report.h ****  *
  91:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
  92:tmk_core/common/report.h ****  */
  93:tmk_core/common/report.h **** enum desktop_usages {
  94:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
  95:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN = 0x81,
  96:tmk_core/common/report.h ****     SYSTEM_SLEEP      = 0x82,
  97:tmk_core/common/report.h ****     SYSTEM_WAKE_UP    = 0x83
  98:tmk_core/common/report.h **** };
  99:tmk_core/common/report.h **** 
 100:tmk_core/common/report.h **** // clang-format on
 101:tmk_core/common/report.h **** 
 102:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 103:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 104:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 105:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 106:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 107:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 108:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 109:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 110:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 111:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 112:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 113:tmk_core/common/report.h **** #    else
 114:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 115:tmk_core/common/report.h **** #    endif
 116:tmk_core/common/report.h **** #endif
 117:tmk_core/common/report.h **** 
 118:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 119:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 120:tmk_core/common/report.h **** #else
 121:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 122:tmk_core/common/report.h **** #endif
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 125:tmk_core/common/report.h **** 
 126:tmk_core/common/report.h **** /* VUSB hardcodes keyboard and mouse+extrakey only */
 127:tmk_core/common/report.h **** #if defined(PROTOCOL_VUSB)
 128:tmk_core/common/report.h **** #    undef KEYBOARD_SHARED_EP
 129:tmk_core/common/report.h **** #    undef MOUSE_SHARED_EP
 130:tmk_core/common/report.h **** #endif
 131:tmk_core/common/report.h **** 
 132:tmk_core/common/report.h **** #ifdef __cplusplus
 133:tmk_core/common/report.h **** extern "C" {
 134:tmk_core/common/report.h **** #endif
 135:tmk_core/common/report.h **** 
 136:tmk_core/common/report.h **** /*
 137:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 138:tmk_core/common/report.h ****  *
 139:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 140:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 141:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 142:tmk_core/common/report.h ****  *
 143:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 144:tmk_core/common/report.h ****  *
 145:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 146:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 147:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 148:tmk_core/common/report.h ****  *
 149:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 150:tmk_core/common/report.h ****  *
 151:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 152:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 153:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  */
 156:tmk_core/common/report.h **** typedef union {
 157:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 158:tmk_core/common/report.h ****     struct {
 159:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 160:tmk_core/common/report.h ****         uint8_t report_id;
 161:tmk_core/common/report.h **** #endif
 162:tmk_core/common/report.h ****         uint8_t mods;
 163:tmk_core/common/report.h ****         uint8_t reserved;
 164:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 165:tmk_core/common/report.h ****     };
 166:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 167:tmk_core/common/report.h ****     struct nkro_report {
 168:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 169:tmk_core/common/report.h ****         uint8_t report_id;
 170:tmk_core/common/report.h **** #    endif
 171:tmk_core/common/report.h ****         uint8_t mods;
 172:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 173:tmk_core/common/report.h ****     } nkro;
 174:tmk_core/common/report.h **** #endif
 175:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 176:tmk_core/common/report.h **** 
 177:tmk_core/common/report.h **** typedef struct {
 178:tmk_core/common/report.h ****     uint8_t  report_id;
 179:tmk_core/common/report.h ****     uint16_t usage;
 180:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 181:tmk_core/common/report.h **** 
 182:tmk_core/common/report.h **** typedef struct {
 183:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 184:tmk_core/common/report.h ****     uint8_t report_id;
 185:tmk_core/common/report.h **** #endif
 186:tmk_core/common/report.h ****     uint8_t buttons;
 187:tmk_core/common/report.h ****     int8_t  x;
 188:tmk_core/common/report.h ****     int8_t  y;
 189:tmk_core/common/report.h ****     int8_t  v;
 190:tmk_core/common/report.h ****     int8_t  h;
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 195:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 196:tmk_core/common/report.h **** #endif
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 199:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 200:tmk_core/common/report.h **** #endif
 201:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 202:tmk_core/common/report.h **** 
 203:tmk_core/common/report.h **** /* keycode to system usage */
 204:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 570               		.loc 4 204 24 view .LVU139
 571               	.LBE46:
 205:tmk_core/common/report.h ****     switch (key) {
 572               		.loc 4 205 5 view .LVU140
 822:tmk_core/common/action.c ****     else if
 573               		.loc 1 822 27 is_stmt 0 view .LVU141
 574 00ee F0E0      		ldi r31,0
 575 00f0 E050      		subi r30,lo8(-(CSWTCH.22))
 576 00f2 F040      		sbci r31,hi8(-(CSWTCH.22))
 577 00f4 8081      		ld r24,Z
 578 00f6 90E0      		ldi r25,0
 579               	/* epilogue start */
 580               		.loc 1 833 1 view .LVU142
 581 00f8 CF91      		pop r28
 582               	.LVL47:
 822:tmk_core/common/action.c ****     else if
 583               		.loc 1 822 27 view .LVU143
 584 00fa 0C94 0000 		jmp host_system_send
 585               	.LVL48:
 586               	.L37:
 823:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(KEYCODE2CONSUMER(code)); }
 587               		.loc 1 823 10 is_stmt 1 view .LVU144
 824:tmk_core/common/action.c **** #endif
 588               		.loc 1 824 9 is_stmt 0 view .LVU145
 589 00fe E8E5      		ldi r30,lo8(88)
 590 0100 EC0F      		add r30,r28
 591 0102 E731      		cpi r30,lo8(23)
 592 0104 00F4      		brsh .L38
 824:tmk_core/common/action.c **** #endif
 593               		.loc 1 824 29 is_stmt 1 view .LVU146
 594               	.LVL49:
 595               	.LBB47:
 596               	.LBI47:
 206:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 207:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 208:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 209:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 210:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 211:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 212:tmk_core/common/report.h ****         default:
 213:tmk_core/common/report.h ****             return 0;
 214:tmk_core/common/report.h ****     }
 215:tmk_core/common/report.h **** }
 216:tmk_core/common/report.h **** 
 217:tmk_core/common/report.h **** /* keycode to consumer usage */
 218:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 597               		.loc 4 218 24 view .LVU147
 598               	.LBE47:
 219:tmk_core/common/report.h ****     switch (key) {
 599               		.loc 4 219 5 view .LVU148
 824:tmk_core/common/action.c **** #endif
 600               		.loc 1 824 29 is_stmt 0 view .LVU149
 601 0106 F0E0      		ldi r31,0
 602 0108 EE0F      		lsl r30
 603 010a FF1F      		rol r31
 604 010c E050      		subi r30,lo8(-(CSWTCH.23))
 605 010e F040      		sbci r31,hi8(-(CSWTCH.23))
 606 0110 8081      		ld r24,Z
 607 0112 9181      		ldd r25,Z+1
 608               	/* epilogue start */
 609               		.loc 1 833 1 view .LVU150
 610 0114 CF91      		pop r28
 611               	.LVL50:
 824:tmk_core/common/action.c **** #endif
 612               		.loc 1 824 29 view .LVU151
 613 0116 0C94 0000 		jmp host_consumer_send
 614               	.LVL51:
 615               	.L38:
 827:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 616               		.loc 1 827 10 is_stmt 1 view .LVU152
 828:tmk_core/common/action.c ****             mousekey_on(code);
 617               		.loc 1 828 9 is_stmt 0 view .LVU153
 618 011a C03F      		cpi r28,lo8(-16)
 619 011c 00F0      		brlo .L27
 829:tmk_core/common/action.c ****             mousekey_send();
 620               		.loc 1 829 13 is_stmt 1 view .LVU154
 621 011e 8C2F      		mov r24,r28
 622 0120 0E94 0000 		call mousekey_on
 623               	.LVL52:
 830:tmk_core/common/action.c ****         }
 624               		.loc 1 830 13 view .LVU155
 625               	/* epilogue start */
 626               		.loc 1 833 1 is_stmt 0 view .LVU156
 627 0124 CF91      		pop r28
 628               	.LVL53:
 830:tmk_core/common/action.c ****         }
 629               		.loc 1 830 13 view .LVU157
 630 0126 0C94 0000 		jmp mousekey_send
 631               	.LVL54:
 632               	.L27:
 633               	/* epilogue start */
 634               		.loc 1 833 1 view .LVU158
 635 012a CF91      		pop r28
 636               	.LVL55:
 637               		.loc 1 833 1 view .LVU159
 638 012c 0895      		ret
 639               		.cfi_endproc
 640               	.LFE117:
 642               		.section	.text.unregister_code,"ax",@progbits
 643               	.global	unregister_code
 645               	unregister_code:
 646               	.LVL56:
 647               	.LFB118:
 834:tmk_core/common/action.c **** 
 835:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 836:tmk_core/common/action.c ****  *
 837:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 838:tmk_core/common/action.c ****  */
 839:tmk_core/common/action.c **** void unregister_code(uint8_t code) {
 648               		.loc 1 839 36 is_stmt 1 view -0
 649               		.cfi_startproc
 650               	/* prologue: function */
 651               	/* frame size = 0 */
 652               	/* stack size = 0 */
 653               	.L__stack_usage = 0
 840:tmk_core/common/action.c ****     if (code == KC_NO) {
 654               		.loc 1 840 5 view .LVU161
 655               		.loc 1 840 8 is_stmt 0 view .LVU162
 656 0000 8823      		tst r24
 657 0002 01F4      		brne .+2
 658 0004 00C0      		rjmp .L44
 841:tmk_core/common/action.c ****         return;
 842:tmk_core/common/action.c ****     }
 843:tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 844:tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 659               		.loc 1 844 10 is_stmt 1 view .LVU163
 660               		.loc 1 844 13 is_stmt 0 view .LVU164
 661 0006 8238      		cpi r24,lo8(-126)
 662 0008 01F4      		brne .L47
 845:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 846:tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 847:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 663               		.loc 1 847 9 is_stmt 1 view .LVU165
 664               		.loc 1 847 15 is_stmt 0 view .LVU166
 665 000a 0E94 0000 		call host_keyboard_leds
 666               	.LVL57:
 667               		.loc 1 847 12 view .LVU167
 668 000e 81FF      		sbrs r24,1
 669 0010 00C0      		rjmp .L44
 848:tmk_core/common/action.c **** #    endif
 849:tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 670               		.loc 1 849 9 is_stmt 1 view .LVU168
 671 0012 89E3      		ldi r24,lo8(57)
 672 0014 0E94 0000 		call add_key
 673               	.LVL58:
 850:tmk_core/common/action.c ****         send_keyboard_report();
 674               		.loc 1 850 9 view .LVU169
 675 0018 0E94 0000 		call send_keyboard_report
 676               	.LVL59:
 851:tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 677               		.loc 1 851 9 view .LVU170
 678 001c 89E3      		ldi r24,lo8(57)
 679               	.L64:
 852:tmk_core/common/action.c ****         send_keyboard_report();
 853:tmk_core/common/action.c ****     }
 854:tmk_core/common/action.c **** 
 855:tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 856:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 857:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 858:tmk_core/common/action.c **** #    endif
 859:tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 860:tmk_core/common/action.c ****         send_keyboard_report();
 861:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 680               		.loc 1 861 9 is_stmt 0 view .LVU171
 681 001e 0E94 0000 		call del_key
 682               	.LVL60:
 683               	.L65:
 862:tmk_core/common/action.c ****         send_keyboard_report();
 684               		.loc 1 862 9 is_stmt 1 view .LVU172
 685 0022 0C94 0000 		jmp send_keyboard_report
 686               	.LVL61:
 687               	.L47:
 855:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 688               		.loc 1 855 10 view .LVU173
 855:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 689               		.loc 1 855 13 is_stmt 0 view .LVU174
 690 0026 8338      		cpi r24,lo8(-125)
 691 0028 01F4      		brne .L49
 857:tmk_core/common/action.c **** #    endif
 692               		.loc 1 857 9 is_stmt 1 view .LVU175
 857:tmk_core/common/action.c **** #    endif
 693               		.loc 1 857 15 is_stmt 0 view .LVU176
 694 002a 0E94 0000 		call host_keyboard_leds
 695               	.LVL62:
 857:tmk_core/common/action.c **** #    endif
 696               		.loc 1 857 12 view .LVU177
 697 002e 80FF      		sbrs r24,0
 698 0030 00C0      		rjmp .L44
 859:tmk_core/common/action.c ****         send_keyboard_report();
 699               		.loc 1 859 9 is_stmt 1 view .LVU178
 700 0032 83E5      		ldi r24,lo8(83)
 701 0034 0E94 0000 		call add_key
 702               	.LVL63:
 860:tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 703               		.loc 1 860 9 view .LVU179
 704 0038 0E94 0000 		call send_keyboard_report
 705               	.LVL64:
 861:tmk_core/common/action.c ****         send_keyboard_report();
 706               		.loc 1 861 9 view .LVU180
 707 003c 83E5      		ldi r24,lo8(83)
 708 003e 00C0      		rjmp .L64
 709               	.LVL65:
 710               	.L49:
 863:tmk_core/common/action.c ****     }
 864:tmk_core/common/action.c **** 
 865:tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 711               		.loc 1 865 10 view .LVU181
 712               		.loc 1 865 13 is_stmt 0 view .LVU182
 713 0040 8438      		cpi r24,lo8(-124)
 714 0042 01F4      		brne .L50
 866:tmk_core/common/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 867:tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 715               		.loc 1 867 9 is_stmt 1 view .LVU183
 716               		.loc 1 867 15 is_stmt 0 view .LVU184
 717 0044 0E94 0000 		call host_keyboard_leds
 718               	.LVL66:
 719               		.loc 1 867 12 view .LVU185
 720 0048 82FF      		sbrs r24,2
 721 004a 00C0      		rjmp .L44
 868:tmk_core/common/action.c **** #    endif
 869:tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 722               		.loc 1 869 9 is_stmt 1 view .LVU186
 723 004c 87E4      		ldi r24,lo8(71)
 724 004e 0E94 0000 		call add_key
 725               	.LVL67:
 870:tmk_core/common/action.c ****         send_keyboard_report();
 726               		.loc 1 870 9 view .LVU187
 727 0052 0E94 0000 		call send_keyboard_report
 728               	.LVL68:
 871:tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 729               		.loc 1 871 9 view .LVU188
 730 0056 87E4      		ldi r24,lo8(71)
 731 0058 00C0      		rjmp .L64
 732               	.LVL69:
 733               	.L50:
 872:tmk_core/common/action.c ****         send_keyboard_report();
 873:tmk_core/common/action.c ****     }
 874:tmk_core/common/action.c **** #endif
 875:tmk_core/common/action.c **** 
 876:tmk_core/common/action.c ****     else if
 734               		.loc 1 876 10 view .LVU189
 877:tmk_core/common/action.c ****         IS_KEY(code) {
 735               		.loc 1 877 9 is_stmt 0 view .LVU190
 736 005a 9CEF      		ldi r25,lo8(-4)
 737 005c 980F      		add r25,r24
 738 005e 913A      		cpi r25,lo8(-95)
 739 0060 00F0      		brlo .L64
 878:tmk_core/common/action.c ****             del_key(code);
 879:tmk_core/common/action.c ****             send_keyboard_report();
 880:tmk_core/common/action.c ****         }
 881:tmk_core/common/action.c ****     else if
 740               		.loc 1 881 10 is_stmt 1 view .LVU191
 882:tmk_core/common/action.c ****         IS_MOD(code) {
 741               		.loc 1 882 9 is_stmt 0 view .LVU192
 742 0062 90E2      		ldi r25,lo8(32)
 743 0064 980F      		add r25,r24
 744 0066 9830      		cpi r25,lo8(8)
 745 0068 00F4      		brsh .L52
 883:tmk_core/common/action.c ****             del_mods(MOD_BIT(code));
 746               		.loc 1 883 13 is_stmt 1 view .LVU193
 747               		.loc 1 883 22 is_stmt 0 view .LVU194
 748 006a 8770      		andi r24,lo8(7)
 749               	.LVL70:
 750               		.loc 1 883 13 view .LVU195
 751 006c 91E0      		ldi r25,lo8(1)
 752 006e 00C0      		rjmp 2f
 753               		1:
 754 0070 990F      		lsl r25
 755               		2:
 756 0072 8A95      		dec r24
 757 0074 02F4      		brpl 1b
 758 0076 892F      		mov r24,r25
 759 0078 0E94 0000 		call del_mods
 760               	.LVL71:
 884:tmk_core/common/action.c ****             send_keyboard_report();
 761               		.loc 1 884 13 is_stmt 1 view .LVU196
 762 007c 00C0      		rjmp .L65
 763               	.LVL72:
 764               	.L52:
 885:tmk_core/common/action.c ****         }
 886:tmk_core/common/action.c ****     else if
 765               		.loc 1 886 10 view .LVU197
 887:tmk_core/common/action.c ****         IS_SYSTEM(code) { host_system_send(0); }
 766               		.loc 1 887 9 is_stmt 0 view .LVU198
 767 007e 9BE5      		ldi r25,lo8(91)
 768 0080 980F      		add r25,r24
 769 0082 9330      		cpi r25,lo8(3)
 770 0084 00F4      		brsh .L53
 771               		.loc 1 887 27 is_stmt 1 discriminator 1 view .LVU199
 772 0086 90E0      		ldi r25,0
 773 0088 80E0      		ldi r24,0
 774               	.LVL73:
 775               		.loc 1 887 27 is_stmt 0 discriminator 1 view .LVU200
 776 008a 0C94 0000 		jmp host_system_send
 777               	.LVL74:
 778               	.L53:
 888:tmk_core/common/action.c ****     else if
 779               		.loc 1 888 10 is_stmt 1 view .LVU201
 889:tmk_core/common/action.c ****         IS_CONSUMER(code) { host_consumer_send(0); }
 780               		.loc 1 889 9 is_stmt 0 view .LVU202
 781 008e 98E5      		ldi r25,lo8(88)
 782 0090 980F      		add r25,r24
 783 0092 9731      		cpi r25,lo8(23)
 784 0094 00F4      		brsh .L54
 785               		.loc 1 889 29 is_stmt 1 discriminator 1 view .LVU203
 786 0096 90E0      		ldi r25,0
 787 0098 80E0      		ldi r24,0
 788               	.LVL75:
 789               		.loc 1 889 29 is_stmt 0 discriminator 1 view .LVU204
 790 009a 0C94 0000 		jmp host_consumer_send
 791               	.LVL76:
 792               	.L54:
 890:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 891:tmk_core/common/action.c ****     else if
 793               		.loc 1 891 10 is_stmt 1 view .LVU205
 892:tmk_core/common/action.c ****         IS_MOUSEKEY(code) {
 794               		.loc 1 892 9 is_stmt 0 view .LVU206
 795 009e 803F      		cpi r24,lo8(-16)
 796 00a0 00F0      		brlo .L44
 893:tmk_core/common/action.c ****             mousekey_off(code);
 797               		.loc 1 893 13 is_stmt 1 view .LVU207
 798 00a2 0E94 0000 		call mousekey_off
 799               	.LVL77:
 894:tmk_core/common/action.c ****             mousekey_send();
 800               		.loc 1 894 13 view .LVU208
 801 00a6 0C94 0000 		jmp mousekey_send
 802               	.LVL78:
 803               	.L44:
 804               	/* epilogue start */
 895:tmk_core/common/action.c ****         }
 896:tmk_core/common/action.c **** #endif
 897:tmk_core/common/action.c **** }
 805               		.loc 1 897 1 is_stmt 0 view .LVU209
 806 00aa 0895      		ret
 807               		.cfi_endproc
 808               	.LFE118:
 810               		.section	.text.tap_code,"ax",@progbits
 811               	.global	tap_code
 813               	tap_code:
 814               	.LVL79:
 815               	.LFB119:
 898:tmk_core/common/action.c **** 
 899:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 900:tmk_core/common/action.c ****  *
 901:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 902:tmk_core/common/action.c ****  */
 903:tmk_core/common/action.c **** void tap_code(uint8_t code) {
 816               		.loc 1 903 29 is_stmt 1 view -0
 817               		.cfi_startproc
 818               		.loc 1 903 29 is_stmt 0 view .LVU211
 819 0000 CF93      		push r28
 820               	.LCFI7:
 821               		.cfi_def_cfa_offset 3
 822               		.cfi_offset 28, -2
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 1 */
 826               	.L__stack_usage = 1
 827 0002 C82F      		mov r28,r24
 904:tmk_core/common/action.c ****     register_code(code);
 828               		.loc 1 904 5 is_stmt 1 view .LVU212
 829 0004 0E94 0000 		call register_code
 830               	.LVL80:
 905:tmk_core/common/action.c ****     if (code == KC_CAPS) {
 831               		.loc 1 905 5 view .LVU213
 832               		.loc 1 905 8 is_stmt 0 view .LVU214
 833 0008 C933      		cpi r28,lo8(57)
 834 000a 01F4      		brne .L68
 906:tmk_core/common/action.c ****         wait_ms(TAP_HOLD_CAPS_DELAY);
 835               		.loc 1 906 9 is_stmt 1 view .LVU215
 836               	.LVL81:
 837               	.LBB48:
 838               	.LBI48:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 839               		.loc 3 166 1 view .LVU216
 840               	.LBB49:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 841               		.loc 3 168 2 view .LVU217
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 842               		.loc 3 172 2 view .LVU218
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 843               		.loc 3 173 2 view .LVU219
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 844               		.loc 3 174 2 view .LVU220
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 845               		.loc 3 184 3 view .LVU221
 846               		.loc 3 187 2 view .LVU222
 847 000c 2FEF      		ldi r18,lo8(255999)
 848 000e 87EE      		ldi r24,hi8(255999)
 849 0010 93E0      		ldi r25,hlo8(255999)
 850 0012 2150      	1:	subi r18,1
 851 0014 8040      		sbci r24,0
 852 0016 9040      		sbci r25,0
 853 0018 01F4      		brne 1b
 854 001a 00C0      		rjmp .
 855 001c 0000      		nop
 856               	.LVL82:
 857               	.L68:
 858               		.loc 3 187 2 is_stmt 0 view .LVU223
 859               	.LBE49:
 860               	.LBE48:
 907:tmk_core/common/action.c ****     } else {
 908:tmk_core/common/action.c ****         wait_ms(TAP_CODE_DELAY);
 909:tmk_core/common/action.c ****     }
 910:tmk_core/common/action.c ****     unregister_code(code);
 861               		.loc 1 910 5 is_stmt 1 view .LVU224
 862 001e 8C2F      		mov r24,r28
 863               	/* epilogue start */
 911:tmk_core/common/action.c **** }
 864               		.loc 1 911 1 is_stmt 0 view .LVU225
 865 0020 CF91      		pop r28
 866               	.LVL83:
 910:tmk_core/common/action.c **** }
 867               		.loc 1 910 5 view .LVU226
 868 0022 0C94 0000 		jmp unregister_code
 869               	.LVL84:
 910:tmk_core/common/action.c **** }
 870               		.loc 1 910 5 view .LVU227
 871               		.cfi_endproc
 872               	.LFE119:
 874               		.section	.text.register_mods,"ax",@progbits
 875               	.global	register_mods
 877               	register_mods:
 878               	.LVL85:
 879               	.LFB120:
 912:tmk_core/common/action.c **** 
 913:tmk_core/common/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:tmk_core/common/action.c ****  *
 915:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 916:tmk_core/common/action.c ****  */
 917:tmk_core/common/action.c **** void register_mods(uint8_t mods) {
 880               		.loc 1 917 34 is_stmt 1 view -0
 881               		.cfi_startproc
 882               	/* prologue: function */
 883               	/* frame size = 0 */
 884               	/* stack size = 0 */
 885               	.L__stack_usage = 0
 918:tmk_core/common/action.c ****     if (mods) {
 886               		.loc 1 918 5 view .LVU229
 887               		.loc 1 918 8 is_stmt 0 view .LVU230
 888 0000 8823      		tst r24
 889 0002 01F0      		breq .L69
 919:tmk_core/common/action.c ****         add_mods(mods);
 890               		.loc 1 919 9 is_stmt 1 view .LVU231
 891 0004 0E94 0000 		call add_mods
 892               	.LVL86:
 920:tmk_core/common/action.c ****         send_keyboard_report();
 893               		.loc 1 920 9 view .LVU232
 894 0008 0C94 0000 		jmp send_keyboard_report
 895               	.LVL87:
 896               	.L69:
 897               	/* epilogue start */
 921:tmk_core/common/action.c ****     }
 922:tmk_core/common/action.c **** }
 898               		.loc 1 922 1 is_stmt 0 view .LVU233
 899 000c 0895      		ret
 900               		.cfi_endproc
 901               	.LFE120:
 903               		.section	.text.unregister_mods,"ax",@progbits
 904               	.global	unregister_mods
 906               	unregister_mods:
 907               	.LVL88:
 908               	.LFB121:
 923:tmk_core/common/action.c **** 
 924:tmk_core/common/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:tmk_core/common/action.c ****  *
 926:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:tmk_core/common/action.c ****  */
 928:tmk_core/common/action.c **** void unregister_mods(uint8_t mods) {
 909               		.loc 1 928 36 is_stmt 1 view -0
 910               		.cfi_startproc
 911               	/* prologue: function */
 912               	/* frame size = 0 */
 913               	/* stack size = 0 */
 914               	.L__stack_usage = 0
 929:tmk_core/common/action.c ****     if (mods) {
 915               		.loc 1 929 5 view .LVU235
 916               		.loc 1 929 8 is_stmt 0 view .LVU236
 917 0000 8823      		tst r24
 918 0002 01F0      		breq .L71
 930:tmk_core/common/action.c ****         del_mods(mods);
 919               		.loc 1 930 9 is_stmt 1 view .LVU237
 920 0004 0E94 0000 		call del_mods
 921               	.LVL89:
 931:tmk_core/common/action.c ****         send_keyboard_report();
 922               		.loc 1 931 9 view .LVU238
 923 0008 0C94 0000 		jmp send_keyboard_report
 924               	.LVL90:
 925               	.L71:
 926               	/* epilogue start */
 932:tmk_core/common/action.c ****     }
 933:tmk_core/common/action.c **** }
 927               		.loc 1 933 1 is_stmt 0 view .LVU239
 928 000c 0895      		ret
 929               		.cfi_endproc
 930               	.LFE121:
 932               		.section	.text.process_action,"ax",@progbits
 933               	.global	process_action
 935               	process_action:
 936               	.LVL91:
 937               	.LFB116:
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 938               		.loc 1 227 59 is_stmt 1 view -0
 939               		.cfi_startproc
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 940               		.loc 1 227 59 is_stmt 0 view .LVU241
 941 0000 8F92      		push r8
 942               	.LCFI8:
 943               		.cfi_def_cfa_offset 3
 944               		.cfi_offset 8, -2
 945 0002 9F92      		push r9
 946               	.LCFI9:
 947               		.cfi_def_cfa_offset 4
 948               		.cfi_offset 9, -3
 949 0004 AF92      		push r10
 950               	.LCFI10:
 951               		.cfi_def_cfa_offset 5
 952               		.cfi_offset 10, -4
 953 0006 BF92      		push r11
 954               	.LCFI11:
 955               		.cfi_def_cfa_offset 6
 956               		.cfi_offset 11, -5
 957 0008 CF92      		push r12
 958               	.LCFI12:
 959               		.cfi_def_cfa_offset 7
 960               		.cfi_offset 12, -6
 961 000a DF92      		push r13
 962               	.LCFI13:
 963               		.cfi_def_cfa_offset 8
 964               		.cfi_offset 13, -7
 965 000c EF92      		push r14
 966               	.LCFI14:
 967               		.cfi_def_cfa_offset 9
 968               		.cfi_offset 14, -8
 969 000e FF92      		push r15
 970               	.LCFI15:
 971               		.cfi_def_cfa_offset 10
 972               		.cfi_offset 15, -9
 973 0010 0F93      		push r16
 974               	.LCFI16:
 975               		.cfi_def_cfa_offset 11
 976               		.cfi_offset 16, -10
 977 0012 1F93      		push r17
 978               	.LCFI17:
 979               		.cfi_def_cfa_offset 12
 980               		.cfi_offset 17, -11
 981 0014 CF93      		push r28
 982               	.LCFI18:
 983               		.cfi_def_cfa_offset 13
 984               		.cfi_offset 28, -12
 985 0016 DF93      		push r29
 986               	.LCFI19:
 987               		.cfi_def_cfa_offset 14
 988               		.cfi_offset 29, -13
 989               	/* prologue: function */
 990               	/* frame size = 0 */
 991               	/* stack size = 12 */
 992               	.L__stack_usage = 12
 993 0018 7C01      		movw r14,r24
 994 001a C62F      		mov r28,r22
 227:tmk_core/common/action.c ****     keyevent_t event = record->event;
 995               		.loc 1 227 59 view .LVU242
 996 001c 172F      		mov r17,r23
 228:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 997               		.loc 1 228 5 is_stmt 1 view .LVU243
 998               	.LVL92:
 230:tmk_core/common/action.c **** #endif
 999               		.loc 1 230 5 view .LVU244
 230:tmk_core/common/action.c **** #endif
 1000               		.loc 1 230 36 is_stmt 0 view .LVU245
 1001 001e FC01      		movw r30,r24
 1002 0020 0581      		ldd r16,Z+5
 1003 0022 0295      		swap r16
 1004 0024 0F70      		andi r16,lo8(15)
 1005               	.LVL93:
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1006               		.loc 1 233 5 is_stmt 1 view .LVU246
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1007               		.loc 1 233 14 is_stmt 0 view .LVU247
 1008 0026 D281      		ldd r29,Z+2
 233:tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 1009               		.loc 1 233 8 view .LVU248
 1010 0028 D111      		cpse r29,__zero_reg__
 235:tmk_core/common/action.c ****     }
 1011               		.loc 1 235 9 is_stmt 1 view .LVU249
 1012 002a 0E94 0000 		call clear_weak_mods
 1013               	.LVL94:
 1014               	.L74:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1015               		.loc 1 239 5 view .LVU250
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1016               		.loc 1 241 5 view .LVU251
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1017               		.loc 1 241 9 is_stmt 0 view .LVU252
 1018 002e 0E94 0000 		call is_oneshot_layer_active
 1019               	.LVL95:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1020               		.loc 1 241 9 view .LVU253
 1021 0032 D82E      		mov r13,r24
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1022               		.loc 1 241 8 view .LVU254
 1023 0034 8823      		tst r24
 1024 0036 01F0      		breq .L75
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1025               		.loc 1 241 35 discriminator 1 view .LVU255
 1026 0038 DD23      		tst r29
 1027 003a 01F0      		breq .L170
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1028               		.loc 1 241 71 discriminator 2 view .LVU256
 1029 003c 812F      		mov r24,r17
 1030 003e 807F      		andi r24,lo8(-16)
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1031               		.loc 1 241 52 discriminator 2 view .LVU257
 1032 0040 8034      		cpi r24,lo8(64)
 1033 0042 01F0      		breq .L76
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1034               		.loc 1 241 87 discriminator 3 view .LVU258
 1035 0044 90E2      		ldi r25,lo8(32)
 1036               	.LVL96:
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1037               		.loc 1 241 87 discriminator 3 view .LVU259
 1038 0046 9C0F      		add r25,r28
 241:tmk_core/common/action.c **** #    ifdef SWAP_HANDS_ENABLE
 1039               		.loc 1 241 84 discriminator 3 view .LVU260
 1040 0048 9830      		cpi r25,lo8(8)
 1041 004a 00F0      		brlo .L170
 243:tmk_core/common/action.c **** #    endif
 1042               		.loc 1 243 9 view .LVU261
 1043 004c 8036      		cpi r24,lo8(96)
 1044 004e 01F4      		brne .L76
 243:tmk_core/common/action.c **** #    endif
 1045               		.loc 1 243 12 discriminator 1 view .LVU262
 1046 0050 C63F      		cpi r28,lo8(-10)
 1047 0052 01F0      		breq .L170
 1048               	.L76:
 246:tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 1049               		.loc 1 246 9 is_stmt 1 view .LVU263
 1050 0054 82E0      		ldi r24,lo8(2)
 1051 0056 0E94 0000 		call clear_oneshot_layer_state
 1052               	.LVL97:
 247:tmk_core/common/action.c ****     }
 1053               		.loc 1 247 9 view .LVU264
 247:tmk_core/common/action.c ****     }
 1054               		.loc 1 247 31 is_stmt 0 view .LVU265
 1055 005a 0E94 0000 		call is_oneshot_layer_active
 1056               	.LVL98:
 247:tmk_core/common/action.c ****     }
 1057               		.loc 1 247 9 view .LVU266
 1058 005e 91E0      		ldi r25,lo8(1)
 1059 0060 D82E      		mov r13,r24
 1060 0062 D926      		eor r13,r25
 1061               	.LVL99:
 1062               	.L75:
 251:tmk_core/common/action.c ****         /* Key and Mods */
 1063               		.loc 1 251 5 is_stmt 1 view .LVU267
 251:tmk_core/common/action.c ****         /* Key and Mods */
 1064               		.loc 1 251 24 is_stmt 0 view .LVU268
 1065 0064 C12E      		mov r12,r17
 1066 0066 C294      		swap r12
 1067 0068 9FE0      		ldi r25,lo8(15)
 1068 006a C922      		and r12,r25
 251:tmk_core/common/action.c ****         /* Key and Mods */
 1069               		.loc 1 251 5 view .LVU269
 1070 006c FBE0      		ldi r31,lo8(11)
 1071 006e FC15      		cp r31,r12
 1072 0070 00F0      		brlo .L77
 1073 0072 EC2D      		mov r30,r12
 1074 0074 F0E0      		ldi r31,0
 1075 0076 E050      		subi r30,lo8(-(gs(.L79)))
 1076 0078 F040      		sbci r31,hi8(-(gs(.L79)))
 1077 007a 0C94 0000 		jmp __tablejump2__
 1078               		.section	.jumptables.gcc.process_action,"a",@progbits
 1079               		.p2align	1
 1080               	.L79:
 1081 0000 0000      		.word gs(.L86)
 1082 0002 0000      		.word gs(.L86)
 1083 0004 0000      		.word gs(.L85)
 1084 0006 0000      		.word gs(.L85)
 1085 0008 0000      		.word gs(.L84)
 1086 000a 0000      		.word gs(.L83)
 1087 000c 0000      		.word gs(.L82)
 1088 000e 0000      		.word gs(.L77)
 1089 0010 0000      		.word gs(.L81)
 1090 0012 0000      		.word gs(.L80)
 1091 0014 0000      		.word gs(.L78)
 1092 0016 0000      		.word gs(.L78)
 1093               		.section	.text.process_action
 1094               	.LVL100:
 1095               	.L170:
 239:tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 1096               		.loc 1 239 10 view .LVU270
 1097 007e D12C      		mov r13,__zero_reg__
 1098 0080 00C0      		rjmp .L75
 1099               	.LVL101:
 1100               	.L86:
 1101               	.LBB50:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 1102               		.loc 1 255 13 is_stmt 1 view .LVU271
 1103 0082 012F      		mov r16,r17
 1104               	.LVL102:
 255:tmk_core/common/action.c ****             if (event.pressed) {
 1105               		.loc 1 255 13 is_stmt 0 view .LVU272
 1106 0084 0F70      		andi r16,lo8(15)
 255:tmk_core/common/action.c ****             if (event.pressed) {
 1107               		.loc 1 255 44 view .LVU273
 1108 0086 812F      		mov r24,r17
 1109 0088 807F      		andi r24,lo8(-16)
 255:tmk_core/common/action.c ****             if (event.pressed) {
 1110               		.loc 1 255 21 view .LVU274
 1111 008a 01F0      		breq .L87
 255:tmk_core/common/action.c ****             if (event.pressed) {
 1112               		.loc 1 255 21 discriminator 2 view .LVU275
 1113 008c 0295      		swap r16
 1114 008e 007F      		andi r16,lo8(-16)
 1115               	.L87:
 1116               	.LVL103:
 256:tmk_core/common/action.c ****                 if (mods) {
 1117               		.loc 1 256 13 is_stmt 1 discriminator 4 view .LVU276
 256:tmk_core/common/action.c ****                 if (mods) {
 1118               		.loc 1 256 16 is_stmt 0 discriminator 4 view .LVU277
 1119 0090 DD23      		tst r29
 1120 0092 01F0      		breq .L88
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1121               		.loc 1 257 17 is_stmt 1 view .LVU278
 257:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1122               		.loc 1 257 20 is_stmt 0 view .LVU279
 1123 0094 0023      		tst r16
 1124 0096 01F0      		breq .L231
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1125               		.loc 1 258 21 is_stmt 1 view .LVU280
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1126               		.loc 1 258 25 is_stmt 0 view .LVU281
 1127 0098 80E2      		ldi r24,lo8(32)
 1128 009a 8C0F      		add r24,r28
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1129               		.loc 1 258 24 view .LVU282
 1130 009c 8830      		cpi r24,lo8(8)
 1131 009e 00F0      		brlo .L90
 258:tmk_core/common/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1132               		.loc 1 258 49 discriminator 1 view .LVU283
 1133 00a0 C111      		cpse r28,__zero_reg__
 1134 00a2 00C0      		rjmp .L91
 1135               	.L90:
 262:tmk_core/common/action.c ****                     } else {
 1136               		.loc 1 262 25 is_stmt 1 view .LVU284
 1137 00a4 802F      		mov r24,r16
 1138 00a6 0E94 0000 		call add_mods
 1139               	.LVL104:
 1140               	.L92:
 266:tmk_core/common/action.c ****                 }
 1141               		.loc 1 266 21 view .LVU285
 1142 00aa 0E94 0000 		call send_keyboard_report
 1143               	.LVL105:
 268:tmk_core/common/action.c ****             } else {
 1144               		.loc 1 268 17 view .LVU286
 1145               	.L231:
 268:tmk_core/common/action.c ****             } else {
 1146               		.loc 1 268 17 is_stmt 0 view .LVU287
 1147               	.LBE50:
 565:tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1148               		.loc 1 565 75 is_stmt 1 view .LVU288
 566:tmk_core/common/action.c ****                         } else {
 1149               		.loc 1 566 29 view .LVU289
 1150 00ae 8C2F      		mov r24,r28
 1151               	.L224:
 654:tmk_core/common/action.c ****                         } else {
 1152               		.loc 1 654 29 view .LVU290
 1153 00b0 0E94 0000 		call register_code
 1154               	.LVL106:
 1155 00b4 00C0      		rjmp .L77
 1156               	.LVL107:
 1157               	.L91:
 1158               	.LBB51:
 264:tmk_core/common/action.c ****                     }
 1159               		.loc 1 264 25 view .LVU291
 1160 00b6 802F      		mov r24,r16
 1161 00b8 0E94 0000 		call add_weak_mods
 1162               	.LVL108:
 1163 00bc 00C0      		rjmp .L92
 1164               	.L88:
 270:tmk_core/common/action.c ****                 if (mods) {
 1165               		.loc 1 270 17 view .LVU292
 1166 00be 8C2F      		mov r24,r28
 1167 00c0 0E94 0000 		call unregister_code
 1168               	.LVL109:
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1169               		.loc 1 271 17 view .LVU293
 271:tmk_core/common/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1170               		.loc 1 271 20 is_stmt 0 view .LVU294
 1171 00c4 0023      		tst r16
 1172 00c6 01F0      		breq .L77
 272:tmk_core/common/action.c ****                         del_mods(mods);
 1173               		.loc 1 272 21 is_stmt 1 view .LVU295
 272:tmk_core/common/action.c ****                         del_mods(mods);
 1174               		.loc 1 272 25 is_stmt 0 view .LVU296
 1175 00c8 80E2      		ldi r24,lo8(32)
 1176 00ca 8C0F      		add r24,r28
 272:tmk_core/common/action.c ****                         del_mods(mods);
 1177               		.loc 1 272 24 view .LVU297
 1178 00cc 8830      		cpi r24,lo8(8)
 1179 00ce 00F0      		brlo .L94
 272:tmk_core/common/action.c ****                         del_mods(mods);
 1180               		.loc 1 272 49 discriminator 1 view .LVU298
 1181 00d0 C111      		cpse r28,__zero_reg__
 1182 00d2 00C0      		rjmp .L95
 1183               	.L94:
 273:tmk_core/common/action.c ****                     } else {
 1184               		.loc 1 273 25 is_stmt 1 view .LVU299
 1185 00d4 802F      		mov r24,r16
 1186 00d6 0E94 0000 		call del_mods
 1187               	.LVL110:
 1188               	.L96:
 277:tmk_core/common/action.c ****                 }
 1189               		.loc 1 277 21 view .LVU300
 1190 00da 0E94 0000 		call send_keyboard_report
 1191               	.LVL111:
 1192               	.L77:
 277:tmk_core/common/action.c ****                 }
 1193               		.loc 1 277 21 is_stmt 0 view .LVU301
 1194               	.LBE51:
 680:tmk_core/common/action.c ****         case ACT_LAYER:
 1195               		.loc 1 680 5 is_stmt 1 view .LVU302
 1196 00de 2C2D      		mov r18,r12
 1197 00e0 2850      		subi r18,8
 1198 00e2 330B      		sbc r19,r19
 1199 00e4 2430      		cpi r18,4
 1200 00e6 3105      		cpc r19,__zero_reg__
 1201 00e8 00F4      		brsh .L162
 687:tmk_core/common/action.c ****             break;
 1202               		.loc 1 687 13 view .LVU303
 1203 00ea 0E94 0000 		call host_keyboard_leds
 1204               	.LVL112:
 1205 00ee 0E94 0000 		call led_set
 1206               	.LVL113:
 688:tmk_core/common/action.c ****         default:
 1207               		.loc 1 688 13 view .LVU304
 1208               	.L162:
 720:tmk_core/common/action.c ****         use_oneshot_swaphands();
 1209               		.loc 1 720 5 view .LVU305
 720:tmk_core/common/action.c ****         use_oneshot_swaphands();
 1210               		.loc 1 720 8 is_stmt 0 view .LVU306
 1211 00f2 DD23      		tst r29
 1212 00f4 01F0      		breq .L163
 720:tmk_core/common/action.c ****         use_oneshot_swaphands();
 1213               		.loc 1 720 43 discriminator 1 view .LVU307
 1214 00f6 107F      		andi r17,lo8(-16)
 1215               	.LVL114:
 720:tmk_core/common/action.c ****         use_oneshot_swaphands();
 1216               		.loc 1 720 23 discriminator 1 view .LVU308
 1217 00f8 1036      		cpi r17,lo8(96)
 1218 00fa 01F4      		brne .L164
 720:tmk_core/common/action.c ****         use_oneshot_swaphands();
 1219               		.loc 1 720 26 discriminator 2 view .LVU309
 1220 00fc C63F      		cpi r28,lo8(-10)
 1221 00fe 01F0      		breq .L163
 1222               	.L164:
 721:tmk_core/common/action.c ****     }
 1223               		.loc 1 721 9 is_stmt 1 view .LVU310
 1224 0100 0E94 0000 		call use_oneshot_swaphands
 1225               	.LVL115:
 1226               	.L163:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 1227               		.loc 1 730 5 view .LVU311
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 1228               		.loc 1 730 8 is_stmt 0 view .LVU312
 1229 0104 DD20      		tst r13
 1230 0106 01F4      		brne .+2
 1231 0108 00C0      		rjmp .L73
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 1232               		.loc 1 730 33 discriminator 1 view .LVU313
 1233 010a 0E94 0000 		call get_oneshot_layer_state
 1234               	.LVL116:
 730:tmk_core/common/action.c ****         record->event.pressed = false;
 1235               		.loc 1 730 28 discriminator 1 view .LVU314
 1236 010e 80FD      		sbrc r24,0
 1237 0110 00C0      		rjmp .L73
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1238               		.loc 1 731 9 is_stmt 1 view .LVU315
 731:tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1239               		.loc 1 731 31 is_stmt 0 view .LVU316
 1240 0112 F701      		movw r30,r14
 1241 0114 1282      		std Z+2,__zero_reg__
 732:tmk_core/common/action.c ****         process_record(record);
 1242               		.loc 1 732 9 is_stmt 1 view .LVU317
 1243 0116 0E94 0000 		call get_oneshot_layer
 1244               	.LVL117:
 1245 011a 0E94 0000 		call layer_on
 1246               	.LVL118:
 733:tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1247               		.loc 1 733 9 view .LVU318
 1248 011e C701      		movw r24,r14
 1249 0120 0E94 0000 		call process_record
 1250               	.LVL119:
 734:tmk_core/common/action.c ****     }
 1251               		.loc 1 734 9 view .LVU319
 1252 0124 0E94 0000 		call get_oneshot_layer
 1253               	.LVL120:
 1254               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 1255               		.loc 1 737 1 is_stmt 0 view .LVU320
 1256 0128 DF91      		pop r29
 1257               	.LVL121:
 737:tmk_core/common/action.c **** 
 1258               		.loc 1 737 1 view .LVU321
 1259 012a CF91      		pop r28
 1260               	.LVL122:
 737:tmk_core/common/action.c **** 
 1261               		.loc 1 737 1 view .LVU322
 1262 012c 1F91      		pop r17
 737:tmk_core/common/action.c **** 
 1263               		.loc 1 737 1 view .LVU323
 1264 012e 0F91      		pop r16
 1265 0130 FF90      		pop r15
 1266 0132 EF90      		pop r14
 1267               	.LVL123:
 737:tmk_core/common/action.c **** 
 1268               		.loc 1 737 1 view .LVU324
 1269 0134 DF90      		pop r13
 1270               	.LVL124:
 737:tmk_core/common/action.c **** 
 1271               		.loc 1 737 1 view .LVU325
 1272 0136 CF90      		pop r12
 1273 0138 BF90      		pop r11
 1274 013a AF90      		pop r10
 1275 013c 9F90      		pop r9
 1276 013e 8F90      		pop r8
 734:tmk_core/common/action.c ****     }
 1277               		.loc 1 734 9 view .LVU326
 1278 0140 0C94 0000 		jmp layer_off
 1279               	.LVL125:
 1280               	.L95:
 1281               	.LBB52:
 275:tmk_core/common/action.c ****                     }
 1282               		.loc 1 275 25 is_stmt 1 view .LVU327
 1283 0144 802F      		mov r24,r16
 1284 0146 0E94 0000 		call del_weak_mods
 1285               	.LVL126:
 1286 014a 00C0      		rjmp .L96
 1287               	.LVL127:
 1288               	.L85:
 275:tmk_core/common/action.c ****                     }
 1289               		.loc 1 275 25 is_stmt 0 view .LVU328
 1290               	.LBE52:
 1291               	.LBB53:
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1292               		.loc 1 284 13 is_stmt 1 view .LVU329
 1293 014c 212F      		mov r18,r17
 1294 014e 2F70      		andi r18,lo8(15)
 1295 0150 B22E      		mov r11,r18
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1296               		.loc 1 284 44 is_stmt 0 view .LVU330
 1297 0152 812F      		mov r24,r17
 1298 0154 807F      		andi r24,lo8(-16)
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1299               		.loc 1 284 21 view .LVU331
 1300 0156 8032      		cpi r24,lo8(32)
 1301 0158 01F0      		breq .L97
 284:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1302               		.loc 1 284 21 discriminator 2 view .LVU332
 1303 015a B294      		swap r11
 1304 015c 80EF      		ldi r24,lo8(-16)
 1305 015e B822      		and r11,r24
 1306               	.L97:
 1307               	.LVL128:
 285:tmk_core/common/action.c **** #    ifndef NO_ACTION_ONESHOT
 1308               		.loc 1 285 13 is_stmt 1 discriminator 4 view .LVU333
 1309 0160 CC23      		tst r28
 1310 0162 01F0      		breq .L98
 1311 0164 C130      		cpi r28,lo8(1)
 1312 0166 01F0      		breq .L99
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1313               		.loc 1 340 21 view .LVU334
 340:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1314               		.loc 1 340 24 is_stmt 0 view .LVU335
 1315 0168 DD23      		tst r29
 1316 016a 01F0      		breq .L107
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1317               		.loc 1 341 25 is_stmt 1 view .LVU336
 341:tmk_core/common/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1318               		.loc 1 341 28 is_stmt 0 view .LVU337
 1319 016c 0023      		tst r16
 1320 016e 01F0      		breq .L108
 1321 0170 00C0      		rjmp .L231
 1322               	.L98:
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1323               		.loc 1 289 21 is_stmt 1 view .LVU338
 289:tmk_core/common/action.c ****                         if (tap_count == 0) {
 1324               		.loc 1 289 24 is_stmt 0 view .LVU339
 1325 0172 DD23      		tst r29
 1326 0174 01F0      		breq .L101
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1327               		.loc 1 290 25 is_stmt 1 view .LVU340
 290:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1328               		.loc 1 290 28 is_stmt 0 view .LVU341
 1329 0176 0111      		cpse r16,__zero_reg__
 1330 0178 00C0      		rjmp .L102
 1331               	.L103:
 304:tmk_core/common/action.c ****                         }
 1332               		.loc 1 304 29 is_stmt 1 view .LVU342
 304:tmk_core/common/action.c ****                         }
 1333               		.loc 1 304 50 is_stmt 0 view .LVU343
 1334 017a 0E94 0000 		call get_oneshot_mods
 1335               	.LVL129:
 304:tmk_core/common/action.c ****                         }
 1336               		.loc 1 304 29 view .LVU344
 1337 017e 8B29      		or r24,r11
 1338               	.LVL130:
 1339               	.L223:
 304:tmk_core/common/action.c ****                         }
 1340               		.loc 1 304 29 view .LVU345
 1341               	.LBE53:
 492:tmk_core/common/action.c ****             } else {
 1342               		.loc 1 492 17 view .LVU346
 1343 0180 0E94 0000 		call register_mods
 1344               	.LVL131:
 1345 0184 00C0      		rjmp .L77
 1346               	.LVL132:
 1347               	.L102:
 1348               	.LBB56:
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1349               		.loc 1 293 32 is_stmt 1 view .LVU347
 293:tmk_core/common/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1350               		.loc 1 293 35 is_stmt 0 view .LVU348
 1351 0186 0130      		cpi r16,lo8(1)
 1352 0188 01F4      		brne .L103
 294:tmk_core/common/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1353               		.loc 1 294 65 is_stmt 1 view .LVU349
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1354               		.loc 1 295 29 view .LVU350
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1355               		.loc 1 295 53 is_stmt 0 view .LVU351
 1356 018a 0E94 0000 		call get_oneshot_mods
 1357               	.LVL133:
 295:tmk_core/common/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1358               		.loc 1 295 29 view .LVU352
 1359 018e 8B29      		or r24,r11
 1360 0190 0E94 0000 		call set_oneshot_mods
 1361               	.LVL134:
 1362 0194 00C0      		rjmp .L77
 1363               	.L101:
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1364               		.loc 1 307 25 is_stmt 1 view .LVU353
 307:tmk_core/common/action.c ****                             clear_oneshot_mods();
 1365               		.loc 1 307 28 is_stmt 0 view .LVU354
 1366 0196 0111      		cpse r16,__zero_reg__
 1367 0198 00C0      		rjmp .L104
 1368               	.L229:
 322:tmk_core/common/action.c ****                             unregister_mods(mods);
 1369               		.loc 1 322 29 is_stmt 1 view .LVU355
 1370 019a 0E94 0000 		call clear_oneshot_mods
 1371               	.LVL135:
 323:tmk_core/common/action.c ****                         }
 1372               		.loc 1 323 29 view .LVU356
 1373               	.L109:
 372:tmk_core/common/action.c ****                             unregister_mods(mods);
 1374               		.loc 1 372 67 view .LVU357
 373:tmk_core/common/action.c ****                         }
 1375               		.loc 1 373 29 view .LVU358
 1376 019e 8B2D      		mov r24,r11
 1377 01a0 0E94 0000 		call unregister_mods
 1378               	.LVL136:
 1379 01a4 00C0      		rjmp .L77
 1380               	.L104:
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1381               		.loc 1 310 32 view .LVU359
 310:tmk_core/common/action.c ****                             // Retain Oneshot mods
 1382               		.loc 1 310 35 is_stmt 0 view .LVU360
 1383 01a6 0130      		cpi r16,lo8(1)
 1384 01a8 01F4      		brne .+2
 1385 01aa 00C0      		rjmp .L77
 1386 01ac 00C0      		rjmp .L229
 1387               	.L99:
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1388               		.loc 1 329 21 is_stmt 1 view .LVU361
 329:tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1389               		.loc 1 329 24 is_stmt 0 view .LVU362
 1390 01ae DD23      		tst r29
 1391 01b0 01F0      		breq .L106
 330:tmk_core/common/action.c ****                             register_mods(mods);
 1392               		.loc 1 330 25 is_stmt 1 view .LVU363
 330:tmk_core/common/action.c ****                             register_mods(mods);
 1393               		.loc 1 330 28 is_stmt 0 view .LVU364
 1394 01b2 0230      		cpi r16,lo8(2)
 1395 01b4 00F0      		brlo .+2
 1396 01b6 00C0      		rjmp .L77
 1397               	.L108:
 359:tmk_core/common/action.c ****                             register_mods(mods);
 1398               		.loc 1 359 67 is_stmt 1 view .LVU365
 360:tmk_core/common/action.c ****                         }
 1399               		.loc 1 360 29 view .LVU366
 1400 01b8 8B2D      		mov r24,r11
 1401 01ba 00C0      		rjmp .L223
 1402               	.L106:
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 1403               		.loc 1 334 25 view .LVU367
 334:tmk_core/common/action.c ****                             unregister_mods(mods);
 1404               		.loc 1 334 28 is_stmt 0 view .LVU368
 1405 01bc 0111      		cpse r16,__zero_reg__
 1406 01be 00C0      		rjmp .L77
 1407 01c0 00C0      		rjmp .L109
 1408               	.L107:
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1409               		.loc 1 363 25 is_stmt 1 view .LVU369
 363:tmk_core/common/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1410               		.loc 1 363 28 is_stmt 0 view .LVU370
 1411 01c2 0023      		tst r16
 1412 01c4 01F0      		breq .L109
 364:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1413               		.loc 1 364 71 is_stmt 1 view .LVU371
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1414               		.loc 1 365 29 view .LVU372
 365:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1415               		.loc 1 365 32 is_stmt 0 view .LVU373
 1416 01c6 C933      		cpi r28,lo8(57)
 1417 01c8 01F4      		brne .L146
 366:tmk_core/common/action.c ****                             } else {
 1418               		.loc 1 366 33 is_stmt 1 view .LVU374
 1419               	.LVL137:
 1420               	.LBB54:
 1421               	.LBI54:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1422               		.loc 3 166 1 view .LVU375
 1423               	.LBB55:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1424               		.loc 3 168 2 view .LVU376
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1425               		.loc 3 172 2 view .LVU377
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1426               		.loc 3 173 2 view .LVU378
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1427               		.loc 3 174 2 view .LVU379
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1428               		.loc 3 184 3 view .LVU380
 1429               		.loc 3 187 2 view .LVU381
 1430 01ca 3FEF      		ldi r19,lo8(255999)
 1431 01cc 87EE      		ldi r24,hi8(255999)
 1432 01ce 93E0      		ldi r25,hlo8(255999)
 1433 01d0 3150      	1:	subi r19,1
 1434 01d2 8040      		sbci r24,0
 1435 01d4 9040      		sbci r25,0
 1436 01d6 01F4      		brne 1b
 1437               	.LVL138:
 1438               	.L230:
 1439               		.loc 3 187 2 is_stmt 0 view .LVU382
 1440               	.LBE55:
 1441               	.LBE54:
 1442               	.LBE56:
 1443               	.LBB57:
 1444               	.LBB58:
 1445 01d8 00C0      		rjmp .
 1446 01da 0000      		nop
 1447               	.L146:
 1448               	.LBE58:
 1449               	.LBE57:
 579:tmk_core/common/action.c ****                         } else {
 1450               		.loc 1 579 29 is_stmt 1 view .LVU383
 1451 01dc 8C2F      		mov r24,r28
 1452 01de 0E94 0000 		call unregister_code
 1453               	.LVL139:
 1454 01e2 00C0      		rjmp .L77
 1455               	.L84:
 383:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1456               		.loc 1 383 13 view .LVU384
 383:tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1457               		.loc 1 383 33 is_stmt 0 view .LVU385
 1458 01e4 812F      		mov r24,r17
 1459 01e6 8695      		lsr r24
 1460 01e8 8695      		lsr r24
 1461 01ea 8370      		andi r24,lo8(3)
 1462 01ec 01F0      		breq .L112
 1463 01ee 8130      		cpi r24,lo8(1)
 1464 01f0 01F0      		breq .+2
 1465 01f2 00C0      		rjmp .L77
 392:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1466               		.loc 1 392 21 is_stmt 1 view .LVU386
 393:tmk_core/common/action.c ****                     } else {
 1467               		.loc 1 393 25 is_stmt 0 view .LVU387
 1468 01f4 8C2F      		mov r24,r28
 1469 01f6 912F      		mov r25,r17
 1470 01f8 9370      		andi r25,lo8(3)
 392:tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1471               		.loc 1 392 24 view .LVU388
 1472 01fa D111      		cpse r29,__zero_reg__
 1473 01fc 00C0      		rjmp .L225
 395:tmk_core/common/action.c ****                     }
 1474               		.loc 1 395 25 is_stmt 1 view .LVU389
 1475 01fe 90E0      		ldi r25,0
 1476 0200 80E0      		ldi r24,0
 1477               	.L225:
 1478 0202 0E94 0000 		call host_consumer_send
 1479               	.LVL140:
 1480 0206 00C0      		rjmp .L77
 1481               	.L112:
 385:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1482               		.loc 1 385 21 view .LVU390
 386:tmk_core/common/action.c ****                     } else {
 1483               		.loc 1 386 25 is_stmt 0 view .LVU391
 1484 0208 8C2F      		mov r24,r28
 1485 020a 912F      		mov r25,r17
 1486 020c 9370      		andi r25,lo8(3)
 385:tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1487               		.loc 1 385 24 view .LVU392
 1488 020e D111      		cpse r29,__zero_reg__
 1489 0210 00C0      		rjmp .L219
 388:tmk_core/common/action.c ****                     }
 1490               		.loc 1 388 25 is_stmt 1 view .LVU393
 1491 0212 90E0      		ldi r25,0
 1492 0214 80E0      		ldi r24,0
 1493               	.L219:
 1494 0216 0E94 0000 		call host_system_send
 1495               	.LVL141:
 1496 021a 00C0      		rjmp .L77
 1497               	.L83:
 404:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1498               		.loc 1 404 13 view .LVU394
 405:tmk_core/common/action.c ****                 switch (action.key.code) {
 1499               		.loc 1 405 17 is_stmt 0 view .LVU395
 1500 021c 8C2F      		mov r24,r28
 404:tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1501               		.loc 1 404 16 view .LVU396
 1502 021e DD23      		tst r29
 1503 0220 01F0      		breq .L116
 405:tmk_core/common/action.c ****                 switch (action.key.code) {
 1504               		.loc 1 405 17 is_stmt 1 view .LVU397
 1505 0222 0E94 0000 		call mousekey_on
 1506               	.LVL142:
 406:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 1507               		.loc 1 406 17 view .LVU398
 419:tmk_core/common/action.c ****                         break;
 1508               		.loc 1 419 25 view .LVU399
 1509               	.L220:
 424:tmk_core/common/action.c **** #    ifdef PS2_MOUSE_ENABLE
 1510               		.loc 1 424 17 view .LVU400
 437:tmk_core/common/action.c ****                         break;
 1511               		.loc 1 437 25 view .LVU401
 1512 0226 0E94 0000 		call mousekey_send
 1513               	.LVL143:
 438:tmk_core/common/action.c ****                 }
 1514               		.loc 1 438 25 view .LVU402
 1515 022a 00C0      		rjmp .L77
 1516               	.L116:
 423:tmk_core/common/action.c ****                 switch (action.key.code) {
 1517               		.loc 1 423 17 view .LVU403
 1518 022c 0E94 0000 		call mousekey_off
 1519               	.LVL144:
 1520 0230 00C0      		rjmp .L220
 1521               	.L81:
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1522               		.loc 1 445 13 view .LVU404
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1523               		.loc 1 445 39 is_stmt 0 view .LVU405
 1524 0232 812F      		mov r24,r17
 1525 0234 8370      		andi r24,lo8(3)
 445:tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1526               		.loc 1 445 16 view .LVU406
 1527 0236 01F0      		breq .+2
 1528 0238 00C0      		rjmp .L117
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1529               		.loc 1 447 17 is_stmt 1 view .LVU407
 447:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1530               		.loc 1 447 20 is_stmt 0 view .LVU408
 1531 023a D111      		cpse r29,__zero_reg__
 1532 023c 00C0      		rjmp .L77
 1533               	.LBB60:
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1534               		.loc 1 448 21 is_stmt 1 view .LVU409
 1535               	.LVL145:
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1536               		.loc 1 449 21 view .LVU410
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1537               		.loc 1 448 61 is_stmt 0 view .LVU411
 1538 023e 2C2F      		mov r18,r28
 1539 0240 2295      		swap r18
 1540 0242 2695      		lsr r18
 1541 0244 2770      		andi r18,lo8(7)
 448:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1542               		.loc 1 448 35 view .LVU412
 1543 0246 220F      		lsl r18
 1544 0248 220F      		lsl r18
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1545               		.loc 1 449 77 view .LVU413
 1546 024a 6C2F      		mov r22,r28
 1547 024c 6F70      		andi r22,lo8(15)
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1548               		.loc 1 449 44 view .LVU414
 1549 024e 862E      		mov r8,r22
 1550 0250 912C      		mov r9,__zero_reg__
 1551 0252 B12C      		mov r11,__zero_reg__
 1552 0254 A12C      		mov r10,__zero_reg__
 449:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1553               		.loc 1 449 35 view .LVU415
 1554 0256 022E      		mov r0,r18
 1555 0258 00C0      		rjmp 2f
 1556               		1:
 1557 025a 880C      		lsl r8
 1558 025c 991C      		rol r9
 1559 025e AA1C      		rol r10
 1560 0260 BB1C      		rol r11
 1561               		2:
 1562 0262 0A94      		dec r0
 1563 0264 02F4      		brpl 1b
 1564               	.LVL146:
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1565               		.loc 1 450 21 is_stmt 1 view .LVU416
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1566               		.loc 1 450 104 is_stmt 0 view .LVU417
 1567 0266 60E0      		ldi r22,0
 1568 0268 70E0      		ldi r23,0
 1569 026a CB01      		movw r24,r22
 1570 026c C4FF      		sbrs r28,4
 1571 026e 00C0      		rjmp .L118
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1572               		.loc 1 450 94 discriminator 1 view .LVU418
 1573 0270 6FE0      		ldi r22,lo8(15)
 1574 0272 70E0      		ldi r23,0
 1575 0274 80E0      		ldi r24,0
 1576 0276 90E0      		ldi r25,0
 1577 0278 00C0      		rjmp 2f
 1578               		1:
 1579 027a 660F      		lsl r22
 1580 027c 771F      		rol r23
 1581 027e 881F      		rol r24
 1582 0280 991F      		rol r25
 1583               		2:
 1584 0282 2A95      		dec r18
 1585 0284 02F4      		brpl 1b
 450:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1586               		.loc 1 450 104 discriminator 1 view .LVU419
 1587 0286 6095      		com r22
 1588 0288 7095      		com r23
 1589 028a 8095      		com r24
 1590 028c 9095      		com r25
 1591               	.L118:
 1592               	.LVL147:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1593               		.loc 1 451 21 is_stmt 1 discriminator 4 view .LVU420
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1594               		.loc 1 451 47 is_stmt 0 discriminator 4 view .LVU421
 1595 028e 212F      		mov r18,r17
 1596 0290 2695      		lsr r18
 1597 0292 2695      		lsr r18
 1598 0294 2370      		andi r18,lo8(3)
 1599 0296 6829      		or r22,r8
 1600               	.LVL148:
 451:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1601               		.loc 1 451 47 discriminator 4 view .LVU422
 1602 0298 7929      		or r23,r9
 1603 029a 8A29      		or r24,r10
 1604 029c 9B29      		or r25,r11
 1605 029e 2230      		cpi r18,lo8(2)
 1606 02a0 01F0      		breq .L119
 1607 02a2 00F4      		brsh .L120
 1608 02a4 2130      		cpi r18,lo8(1)
 1609 02a6 01F0      		breq .L121
 453:tmk_core/common/action.c ****                             break;
 1610               		.loc 1 453 29 is_stmt 1 view .LVU423
 1611 02a8 0E94 0000 		call default_layer_and
 1612               	.LVL149:
 454:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1613               		.loc 1 454 29 view .LVU424
 1614 02ac 00C0      		rjmp .L77
 1615               	.L121:
 456:tmk_core/common/action.c ****                             break;
 1616               		.loc 1 456 29 view .LVU425
 1617 02ae 0E94 0000 		call default_layer_or
 1618               	.LVL150:
 457:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1619               		.loc 1 457 29 view .LVU426
 1620 02b2 00C0      		rjmp .L77
 1621               	.L119:
 459:tmk_core/common/action.c ****                             break;
 1622               		.loc 1 459 29 view .LVU427
 1623 02b4 0E94 0000 		call default_layer_xor
 1624               	.LVL151:
 460:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1625               		.loc 1 460 29 view .LVU428
 1626 02b8 00C0      		rjmp .L77
 1627               	.L120:
 462:tmk_core/common/action.c ****                             break;
 1628               		.loc 1 462 29 view .LVU429
 1629 02ba 0E94 0000 		call default_layer_set
 1630               	.LVL152:
 463:tmk_core/common/action.c ****                     }
 1631               		.loc 1 463 29 view .LVU430
 1632 02be 00C0      		rjmp .L77
 1633               	.LVL153:
 1634               	.L117:
 463:tmk_core/common/action.c ****                     }
 1635               		.loc 1 463 29 is_stmt 0 view .LVU431
 1636               	.LBE60:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1637               		.loc 1 468 17 is_stmt 1 view .LVU432
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1638               		.loc 1 468 21 is_stmt 0 view .LVU433
 1639 02c0 8695      		lsr r24
 1640 02c2 DD23      		tst r29
 1641 02c4 01F0      		breq .L123
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1642               		.loc 1 468 21 discriminator 1 view .LVU434
 1643 02c6 812F      		mov r24,r17
 1644 02c8 8170      		andi r24,lo8(1)
 1645               	.L123:
 468:tmk_core/common/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1646               		.loc 1 468 20 discriminator 4 view .LVU435
 1647 02ca 8823      		tst r24
 1648 02cc 01F4      		brne .+2
 1649 02ce 00C0      		rjmp .L77
 1650               	.LBB61:
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1651               		.loc 1 469 21 is_stmt 1 view .LVU436
 1652               	.LVL154:
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1653               		.loc 1 470 21 view .LVU437
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1654               		.loc 1 469 61 is_stmt 0 view .LVU438
 1655 02d0 2C2F      		mov r18,r28
 1656 02d2 2295      		swap r18
 1657 02d4 2695      		lsr r18
 1658 02d6 2770      		andi r18,lo8(7)
 469:tmk_core/common/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1659               		.loc 1 469 35 view .LVU439
 1660 02d8 220F      		lsl r18
 1661 02da 220F      		lsl r18
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1662               		.loc 1 470 77 view .LVU440
 1663 02dc 6C2F      		mov r22,r28
 1664 02de 6F70      		andi r22,lo8(15)
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1665               		.loc 1 470 44 view .LVU441
 1666 02e0 862E      		mov r8,r22
 1667 02e2 912C      		mov r9,__zero_reg__
 1668 02e4 B12C      		mov r11,__zero_reg__
 1669 02e6 A12C      		mov r10,__zero_reg__
 470:tmk_core/common/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1670               		.loc 1 470 35 view .LVU442
 1671 02e8 022E      		mov r0,r18
 1672 02ea 00C0      		rjmp 2f
 1673               		1:
 1674 02ec 880C      		lsl r8
 1675 02ee 991C      		rol r9
 1676 02f0 AA1C      		rol r10
 1677 02f2 BB1C      		rol r11
 1678               		2:
 1679 02f4 0A94      		dec r0
 1680 02f6 02F4      		brpl 1b
 1681               	.LVL155:
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1682               		.loc 1 471 21 is_stmt 1 view .LVU443
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1683               		.loc 1 471 104 is_stmt 0 view .LVU444
 1684 02f8 60E0      		ldi r22,0
 1685 02fa 70E0      		ldi r23,0
 1686 02fc CB01      		movw r24,r22
 1687 02fe C4FF      		sbrs r28,4
 1688 0300 00C0      		rjmp .L124
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1689               		.loc 1 471 94 discriminator 1 view .LVU445
 1690 0302 6FE0      		ldi r22,lo8(15)
 1691 0304 70E0      		ldi r23,0
 1692 0306 80E0      		ldi r24,0
 1693 0308 90E0      		ldi r25,0
 1694 030a 00C0      		rjmp 2f
 1695               		1:
 1696 030c 660F      		lsl r22
 1697 030e 771F      		rol r23
 1698 0310 881F      		rol r24
 1699 0312 991F      		rol r25
 1700               		2:
 1701 0314 2A95      		dec r18
 1702 0316 02F4      		brpl 1b
 471:tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1703               		.loc 1 471 104 discriminator 1 view .LVU446
 1704 0318 6095      		com r22
 1705 031a 7095      		com r23
 1706 031c 8095      		com r24
 1707 031e 9095      		com r25
 1708               	.L124:
 1709               	.LVL156:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1710               		.loc 1 472 21 is_stmt 1 discriminator 4 view .LVU447
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1711               		.loc 1 472 47 is_stmt 0 discriminator 4 view .LVU448
 1712 0320 212F      		mov r18,r17
 1713 0322 2695      		lsr r18
 1714 0324 2695      		lsr r18
 1715 0326 2370      		andi r18,lo8(3)
 1716 0328 6829      		or r22,r8
 1717               	.LVL157:
 472:tmk_core/common/action.c ****                         case OP_BIT_AND:
 1718               		.loc 1 472 47 discriminator 4 view .LVU449
 1719 032a 7929      		or r23,r9
 1720 032c 8A29      		or r24,r10
 1721 032e 9B29      		or r25,r11
 1722 0330 2230      		cpi r18,lo8(2)
 1723 0332 01F0      		breq .L125
 1724 0334 00F4      		brsh .L126
 1725 0336 2130      		cpi r18,lo8(1)
 1726 0338 01F0      		breq .L127
 474:tmk_core/common/action.c ****                             break;
 1727               		.loc 1 474 29 is_stmt 1 view .LVU450
 1728 033a 0E94 0000 		call layer_and
 1729               	.LVL158:
 475:tmk_core/common/action.c ****                         case OP_BIT_OR:
 1730               		.loc 1 475 29 view .LVU451
 1731 033e 00C0      		rjmp .L77
 1732               	.L127:
 477:tmk_core/common/action.c ****                             break;
 1733               		.loc 1 477 29 view .LVU452
 1734 0340 0E94 0000 		call layer_or
 1735               	.LVL159:
 478:tmk_core/common/action.c ****                         case OP_BIT_XOR:
 1736               		.loc 1 478 29 view .LVU453
 1737 0344 00C0      		rjmp .L77
 1738               	.L125:
 480:tmk_core/common/action.c ****                             break;
 1739               		.loc 1 480 29 view .LVU454
 1740 0346 0E94 0000 		call layer_xor
 1741               	.LVL160:
 481:tmk_core/common/action.c ****                         case OP_BIT_SET:
 1742               		.loc 1 481 29 view .LVU455
 1743 034a 00C0      		rjmp .L77
 1744               	.L126:
 483:tmk_core/common/action.c ****                             break;
 1745               		.loc 1 483 29 view .LVU456
 1746 034c 0E94 0000 		call layer_state_set
 1747               	.LVL161:
 484:tmk_core/common/action.c ****                     }
 1748               		.loc 1 484 29 view .LVU457
 1749 0350 00C0      		rjmp .L77
 1750               	.LVL162:
 1751               	.L80:
 484:tmk_core/common/action.c ****                     }
 1752               		.loc 1 484 29 is_stmt 0 view .LVU458
 1753               	.LBE61:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1754               		.loc 1 490 13 is_stmt 1 view .LVU459
 1755 0352 012F      		mov r16,r17
 1756               	.LVL163:
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1757               		.loc 1 490 13 is_stmt 0 view .LVU460
 1758 0354 0F70      		andi r16,lo8(15)
 490:tmk_core/common/action.c ****                 layer_on(action.layer_mods.layer);
 1759               		.loc 1 490 16 view .LVU461
 1760 0356 DD23      		tst r29
 1761 0358 01F0      		breq .L128
 491:tmk_core/common/action.c ****                 register_mods(action.layer_mods.mods);
 1762               		.loc 1 491 17 is_stmt 1 view .LVU462
 1763 035a 802F      		mov r24,r16
 1764 035c 0E94 0000 		call layer_on
 1765               	.LVL164:
 492:tmk_core/common/action.c ****             } else {
 1766               		.loc 1 492 17 view .LVU463
 1767 0360 8C2F      		mov r24,r28
 1768 0362 00C0      		rjmp .L223
 1769               	.L128:
 494:tmk_core/common/action.c ****                 layer_off(action.layer_mods.layer);
 1770               		.loc 1 494 17 view .LVU464
 1771 0364 8C2F      		mov r24,r28
 1772 0366 0E94 0000 		call unregister_mods
 1773               	.LVL165:
 495:tmk_core/common/action.c ****             }
 1774               		.loc 1 495 17 view .LVU465
 1775 036a 802F      		mov r24,r16
 1776               	.L228:
 582:tmk_core/common/action.c ****                         }
 1777               		.loc 1 582 29 is_stmt 0 view .LVU466
 1778 036c 0E94 0000 		call layer_off
 1779               	.LVL166:
 1780 0370 00C0      		rjmp .L77
 1781               	.LVL167:
 1782               	.L78:
 501:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 1783               		.loc 1 501 13 is_stmt 1 view .LVU467
 1784 0372 C23F      		cpi r28,lo8(-14)
 1785 0374 01F0      		breq .L129
 1786 0376 00F4      		brsh .L130
 1787 0378 C03F      		cpi r28,lo8(-16)
 1788 037a 01F0      		breq .L131
 1789 037c C13F      		cpi r28,lo8(-15)
 1790 037e 01F0      		breq .L132
 1791               	.L133:
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1792               		.loc 1 563 21 view .LVU468
 563:tmk_core/common/action.c ****                         if (tap_count > 0) {
 1793               		.loc 1 563 24 is_stmt 0 view .LVU469
 1794 0380 DD23      		tst r29
 1795 0382 01F4      		brne .+2
 1796 0384 00C0      		rjmp .L142
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1797               		.loc 1 564 25 is_stmt 1 view .LVU470
 564:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1798               		.loc 1 564 28 is_stmt 0 view .LVU471
 1799 0386 0111      		cpse r16,__zero_reg__
 1800 0388 00C0      		rjmp .L231
 568:tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1801               		.loc 1 568 76 is_stmt 1 view .LVU472
 569:tmk_core/common/action.c ****                         }
 1802               		.loc 1 569 29 view .LVU473
 1803 038a 812F      		mov r24,r17
 1804 038c 8F71      		andi r24,lo8(31)
 1805 038e 00C0      		rjmp .L227
 1806               	.L130:
 1807 0390 C33F      		cpi r28,lo8(-13)
 1808 0392 01F0      		breq .L134
 1809 0394 C43F      		cpi r28,lo8(-12)
 1810 0396 01F4      		brne .L133
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1811               		.loc 1 549 21 view .LVU474
 549:tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1812               		.loc 1 549 24 is_stmt 0 view .LVU475
 1813 0398 DD23      		tst r29
 1814 039a 01F0      		breq .L141
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1815               		.loc 1 550 25 is_stmt 1 view .LVU476
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1816               		.loc 1 550 50 is_stmt 0 view .LVU477
 1817 039c 012F      		mov r16,r17
 1818               	.LVL168:
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1819               		.loc 1 550 50 view .LVU478
 1820 039e 0F71      		andi r16,lo8(31)
 550:tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1821               		.loc 1 550 25 view .LVU479
 1822 03a0 802F      		mov r24,r16
 1823 03a2 0E94 0000 		call layer_on
 1824               	.LVL169:
 551:tmk_core/common/action.c ****                     } else {
 1825               		.loc 1 551 25 is_stmt 1 view .LVU480
 1826 03a6 63E0      		ldi r22,lo8(3)
 1827 03a8 802F      		mov r24,r16
 1828 03aa 0E94 0000 		call set_oneshot_layer
 1829               	.LVL170:
 1830 03ae 00C0      		rjmp .L77
 1831               	.LVL171:
 1832               	.L131:
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1833               		.loc 1 504 21 view .LVU481
 504:tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1834               		.loc 1 504 24 is_stmt 0 view .LVU482
 1835 03b0 DD23      		tst r29
 1836 03b2 01F0      		breq .L136
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1837               		.loc 1 505 25 is_stmt 1 view .LVU483
 505:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1838               		.loc 1 505 28 is_stmt 0 view .LVU484
 1839 03b4 0111      		cpse r16,__zero_reg__
 1840 03b6 00C0      		rjmp .L77
 1841               	.L137:
 506:tmk_core/common/action.c ****                         }
 1842               		.loc 1 506 29 is_stmt 1 view .LVU485
 1843 03b8 812F      		mov r24,r17
 1844 03ba 8F71      		andi r24,lo8(31)
 1845 03bc 0E94 0000 		call layer_invert
 1846               	.LVL172:
 1847 03c0 00C0      		rjmp .L77
 1848               	.L136:
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1849               		.loc 1 509 25 view .LVU486
 509:tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1850               		.loc 1 509 28 is_stmt 0 view .LVU487
 1851 03c2 0230      		cpi r16,lo8(2)
 1852 03c4 00F0      		brlo .+2
 1853 03c6 00C0      		rjmp .L77
 1854 03c8 00C0      		rjmp .L137
 1855               	.L132:
 515:tmk_core/common/action.c ****                     break;
 1856               		.loc 1 515 21 is_stmt 1 view .LVU488
 1857 03ca 812F      		mov r24,r17
 1858 03cc 8F71      		andi r24,lo8(31)
 515:tmk_core/common/action.c ****                     break;
 1859               		.loc 1 515 68 is_stmt 0 view .LVU489
 1860 03ce DD23      		tst r29
 1861 03d0 01F0      		breq .L228
 1862               	.L227:
 569:tmk_core/common/action.c ****                         }
 1863               		.loc 1 569 29 view .LVU490
 1864 03d2 0E94 0000 		call layer_on
 1865               	.LVL173:
 1866 03d6 00C0      		rjmp .L77
 1867               	.L129:
 518:tmk_core/common/action.c ****                     break;
 1868               		.loc 1 518 21 is_stmt 1 view .LVU491
 1869 03d8 812F      		mov r24,r17
 1870 03da 8F71      		andi r24,lo8(31)
 518:tmk_core/common/action.c ****                     break;
 1871               		.loc 1 518 69 is_stmt 0 view .LVU492
 1872 03dc DD23      		tst r29
 1873 03de 01F0      		breq .L227
 1874 03e0 00C0      		rjmp .L228
 1875               	.L134:
 521:tmk_core/common/action.c ****                     break;
 1876               		.loc 1 521 21 is_stmt 1 view .LVU493
 521:tmk_core/common/action.c ****                     break;
 1877               		.loc 1 521 70 is_stmt 0 view .LVU494
 1878 03e2 DD23      		tst r29
 1879 03e4 01F0      		breq .L140
 521:tmk_core/common/action.c ****                     break;
 1880               		.loc 1 521 37 discriminator 1 view .LVU495
 1881 03e6 812F      		mov r24,r17
 1882 03e8 8F71      		andi r24,lo8(31)
 1883 03ea 0E94 0000 		call layer_move
 1884               	.LVL174:
 1885 03ee 00C0      		rjmp .L77
 1886               	.L140:
 521:tmk_core/common/action.c ****                     break;
 1887               		.loc 1 521 72 discriminator 2 view .LVU496
 1888 03f0 0E94 0000 		call layer_clear
 1889               	.LVL175:
 1890 03f4 00C0      		rjmp .L77
 1891               	.L141:
 553:tmk_core/common/action.c ****                         if (tap_count > 1) {
 1892               		.loc 1 553 25 is_stmt 1 view .LVU497
 1893 03f6 81E0      		ldi r24,lo8(1)
 1894 03f8 0E94 0000 		call clear_oneshot_layer_state
 1895               	.LVL176:
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1896               		.loc 1 554 25 view .LVU498
 554:tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1897               		.loc 1 554 28 is_stmt 0 view .LVU499
 1898 03fc 0230      		cpi r16,lo8(2)
 1899 03fe 00F4      		brsh .+2
 1900 0400 00C0      		rjmp .L77
 555:tmk_core/common/action.c ****                         }
 1901               		.loc 1 555 29 is_stmt 1 view .LVU500
 1902 0402 82E0      		ldi r24,lo8(2)
 1903 0404 0E94 0000 		call clear_oneshot_layer_state
 1904               	.LVL177:
 1905 0408 00C0      		rjmp .L77
 1906               	.L142:
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1907               		.loc 1 572 25 view .LVU501
 572:tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1908               		.loc 1 572 28 is_stmt 0 view .LVU502
 1909 040a 0023      		tst r16
 1910 040c 01F0      		breq .L144
 573:tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1911               		.loc 1 573 77 is_stmt 1 view .LVU503
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1912               		.loc 1 574 29 view .LVU504
 574:tmk_core/common/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1913               		.loc 1 574 32 is_stmt 0 view .LVU505
 1914 040e C933      		cpi r28,lo8(57)
 1915 0410 01F0      		breq .+2
 1916 0412 00C0      		rjmp .L146
 575:tmk_core/common/action.c ****                             } else {
 1917               		.loc 1 575 33 is_stmt 1 view .LVU506
 1918               	.LVL178:
 1919               	.LBB62:
 1920               	.LBI57:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 1921               		.loc 3 166 1 view .LVU507
 1922               	.LBB59:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1923               		.loc 3 168 2 view .LVU508
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1924               		.loc 3 172 2 view .LVU509
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1925               		.loc 3 173 2 view .LVU510
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 1926               		.loc 3 174 2 view .LVU511
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 1927               		.loc 3 184 3 view .LVU512
 1928               		.loc 3 187 2 view .LVU513
 1929 0414 EFEF      		ldi r30,lo8(255999)
 1930 0416 F7EE      		ldi r31,hi8(255999)
 1931 0418 23E0      		ldi r18,hlo8(255999)
 1932 041a E150      	1:	subi r30,1
 1933 041c F040      		sbci r31,0
 1934 041e 2040      		sbci r18,0
 1935 0420 01F4      		brne 1b
 1936 0422 00C0      		rjmp .L230
 1937               	.LVL179:
 1938               	.L144:
 1939               		.loc 3 187 2 is_stmt 0 view .LVU514
 1940               	.LBE59:
 1941               	.LBE62:
 581:tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1942               		.loc 1 581 79 is_stmt 1 view .LVU515
 582:tmk_core/common/action.c ****                         }
 1943               		.loc 1 582 29 view .LVU516
 1944 0424 812F      		mov r24,r17
 1945 0426 8F71      		andi r24,lo8(31)
 1946 0428 00C0      		rjmp .L228
 1947               	.L82:
 598:tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 1948               		.loc 1 598 13 view .LVU517
 1949 042a E0E1      		ldi r30,lo8(16)
 1950 042c EC0F      		add r30,r28
 1951 042e E730      		cpi r30,lo8(7)
 1952 0430 00F4      		brsh .L147
 1953 0432 F0E0      		ldi r31,0
 1954 0434 E050      		subi r30,lo8(-(gs(.L149)))
 1955 0436 F040      		sbci r31,hi8(-(gs(.L149)))
 1956 0438 0C94 0000 		jmp __tablejump2__
 1957               		.section	.jumptables.gcc.process_action,"a",@progbits
 1958               		.p2align	1
 1959               	.L149:
 1960 0018 0000      		.word gs(.L155)
 1961 001a 0000      		.word gs(.L154)
 1962 001c 0000      		.word gs(.L153)
 1963 001e 0000      		.word gs(.L152)
 1964 0020 0000      		.word gs(.L151)
 1965 0022 0000      		.word gs(.L150)
 1966 0024 0000      		.word gs(.L148)
 1967               		.section	.text.process_action
 1968               	.L155:
 600:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 1969               		.loc 1 600 21 view .LVU518
 600:tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 1970               		.loc 1 600 24 is_stmt 0 view .LVU519
 1971 043c DD23      		tst r29
 1972 043e 01F4      		brne .+2
 1973 0440 00C0      		rjmp .L77
 1974               	.L158:
 601:tmk_core/common/action.c ****                     }
 1975               		.loc 1 601 25 is_stmt 1 view .LVU520
 1976 0442 8091 0000 		lds r24,swap_hands
 1977 0446 91E0      		ldi r25,lo8(1)
 1978 0448 8927      		eor r24,r25
 1979               	.L226:
 612:tmk_core/common/action.c ****                     }
 1980               		.loc 1 612 36 is_stmt 0 view .LVU521
 1981 044a 8093 0000 		sts swap_hands,r24
 1982 044e 00C0      		rjmp .L77
 1983               	.L153:
 605:tmk_core/common/action.c ****                     break;
 1984               		.loc 1 605 21 is_stmt 1 view .LVU522
 605:tmk_core/common/action.c ****                     break;
 1985               		.loc 1 605 32 is_stmt 0 view .LVU523
 1986 0450 D093 0000 		sts swap_hands,r29
 606:tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 1987               		.loc 1 606 21 is_stmt 1 view .LVU524
 1988 0454 00C0      		rjmp .L77
 1989               	.L152:
 608:tmk_core/common/action.c ****                     break;
 1990               		.loc 1 608 21 view .LVU525
 1991 0456 81E0      		ldi r24,lo8(1)
 1992 0458 8D27      		eor r24,r29
 1993 045a 00C0      		rjmp .L226
 1994               	.L150:
 611:tmk_core/common/action.c ****                         swap_hands = true;
 1995               		.loc 1 611 21 view .LVU526
 611:tmk_core/common/action.c ****                         swap_hands = true;
 1996               		.loc 1 611 24 is_stmt 0 view .LVU527
 1997 045c D111      		cpse r29,__zero_reg__
 1998 045e 00C0      		rjmp .L77
 612:tmk_core/common/action.c ****                     }
 1999               		.loc 1 612 25 is_stmt 1 view .LVU528
 612:tmk_core/common/action.c ****                     }
 2000               		.loc 1 612 36 is_stmt 0 view .LVU529
 2001 0460 81E0      		ldi r24,lo8(1)
 2002 0462 00C0      		rjmp .L226
 2003               	.L151:
 616:tmk_core/common/action.c ****                         swap_hands = false;
 2004               		.loc 1 616 21 is_stmt 1 view .LVU530
 616:tmk_core/common/action.c ****                         swap_hands = false;
 2005               		.loc 1 616 24 is_stmt 0 view .LVU531
 2006 0464 D111      		cpse r29,__zero_reg__
 2007 0466 00C0      		rjmp .L77
 617:tmk_core/common/action.c ****                     }
 2008               		.loc 1 617 25 is_stmt 1 view .LVU532
 617:tmk_core/common/action.c ****                     }
 2009               		.loc 1 617 36 is_stmt 0 view .LVU533
 2010 0468 1092 0000 		sts swap_hands,__zero_reg__
 2011 046c 00C0      		rjmp .L77
 2012               	.L148:
 622:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 2013               		.loc 1 622 21 is_stmt 1 view .LVU534
 622:tmk_core/common/action.c ****                         set_oneshot_swaphands();
 2014               		.loc 1 622 24 is_stmt 0 view .LVU535
 2015 046e DD23      		tst r29
 2016 0470 01F0      		breq .L156
 623:tmk_core/common/action.c ****                     } else {
 2017               		.loc 1 623 25 is_stmt 1 view .LVU536
 2018 0472 0E94 0000 		call set_oneshot_swaphands
 2019               	.LVL180:
 2020 0476 00C0      		rjmp .L77
 2021               	.L156:
 625:tmk_core/common/action.c ****                     }
 2022               		.loc 1 625 25 view .LVU537
 2023 0478 0E94 0000 		call release_oneshot_swaphands
 2024               	.LVL181:
 2025 047c 00C0      		rjmp .L77
 2026               	.L154:
 634:tmk_core/common/action.c ****                         if (swap_held) {
 2027               		.loc 1 634 21 view .LVU538
 634:tmk_core/common/action.c ****                         if (swap_held) {
 2028               		.loc 1 634 24 is_stmt 0 view .LVU539
 2029 047e DD23      		tst r29
 2030 0480 01F0      		breq .L157
 635:tmk_core/common/action.c ****                             swap_held = false;
 2031               		.loc 1 635 25 is_stmt 1 view .LVU540
 635:tmk_core/common/action.c ****                             swap_held = false;
 2032               		.loc 1 635 28 is_stmt 0 view .LVU541
 2033 0482 8091 0000 		lds r24,swap_held
 2034 0486 8823      		tst r24
 2035 0488 01F0      		breq .L158
 2036               	.L221:
 663:tmk_core/common/action.c ****                         }
 2037               		.loc 1 663 29 is_stmt 1 view .LVU542
 663:tmk_core/common/action.c ****                         }
 2038               		.loc 1 663 40 is_stmt 0 view .LVU543
 2039 048a 1092 0000 		sts swap_held,__zero_reg__
 2040 048e 00C0      		rjmp .L77
 2041               	.L157:
 641:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 2042               		.loc 1 641 25 is_stmt 1 view .LVU544
 641:tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 2043               		.loc 1 641 28 is_stmt 0 view .LVU545
 2044 0490 0023      		tst r16
 2045 0492 01F0      		breq .L158
 2046 0494 00C0      		rjmp .L77
 2047               	.L147:
 648:tmk_core/common/action.c ****                         if (swap_held) {
 2048               		.loc 1 648 21 is_stmt 1 view .LVU546
 2049 0496 8091 0000 		lds r24,swap_held
 648:tmk_core/common/action.c ****                         if (swap_held) {
 2050               		.loc 1 648 24 is_stmt 0 view .LVU547
 2051 049a 0023      		tst r16
 2052 049c 01F0      		breq .L159
 649:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2053               		.loc 1 649 25 is_stmt 1 view .LVU548
 649:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2054               		.loc 1 649 28 is_stmt 0 view .LVU549
 2055 049e 8823      		tst r24
 2056 04a0 01F0      		breq .L160
 650:tmk_core/common/action.c ****                             swap_held  = false;
 2057               		.loc 1 650 29 is_stmt 1 view .LVU550
 2058 04a2 8091 0000 		lds r24,swap_hands
 2059 04a6 91E0      		ldi r25,lo8(1)
 2060 04a8 8927      		eor r24,r25
 650:tmk_core/common/action.c ****                             swap_held  = false;
 2061               		.loc 1 650 40 is_stmt 0 view .LVU551
 2062 04aa 8093 0000 		sts swap_hands,r24
 651:tmk_core/common/action.c ****                         }
 2063               		.loc 1 651 29 is_stmt 1 view .LVU552
 651:tmk_core/common/action.c ****                         }
 2064               		.loc 1 651 40 is_stmt 0 view .LVU553
 2065 04ae 1092 0000 		sts swap_held,__zero_reg__
 2066               	.L160:
 653:tmk_core/common/action.c ****                             register_code(action.swap.code);
 2067               		.loc 1 653 25 is_stmt 1 view .LVU554
 654:tmk_core/common/action.c ****                         } else {
 2068               		.loc 1 654 29 is_stmt 0 view .LVU555
 2069 04b2 8C2F      		mov r24,r28
 653:tmk_core/common/action.c ****                             register_code(action.swap.code);
 2070               		.loc 1 653 28 view .LVU556
 2071 04b4 D111      		cpse r29,__zero_reg__
 2072 04b6 00C0      		rjmp .L224
 656:tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 2073               		.loc 1 656 29 is_stmt 1 view .LVU557
 2074               	.LVL182:
 2075               	.LBB63:
 2076               	.LBI63:
 166:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** {
 2077               		.loc 3 166 1 view .LVU558
 2078               	.LBB64:
 168:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2079               		.loc 3 168 2 view .LVU559
 172:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2080               		.loc 3 172 2 view .LVU560
 173:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2081               		.loc 3 173 2 view .LVU561
 174:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 
 2082               		.loc 3 174 2 view .LVU562
 184:/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/util/delay.h **** 	#endif
 2083               		.loc 3 184 3 view .LVU563
 2084               		.loc 3 187 2 view .LVU564
 2085               		.loc 3 187 2 is_stmt 0 view .LVU565
 2086               	.LBE64:
 2087               	.LBE63:
 657:tmk_core/common/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 2088               		.loc 1 657 29 is_stmt 1 view .LVU566
 2089 04b8 0E94 0000 		call unregister_code
 2090               	.LVL183:
 658:tmk_core/common/action.c ****                         }
 2091               		.loc 1 658 29 view .LVU567
 658:tmk_core/common/action.c ****                         }
 2092               		.loc 1 658 37 is_stmt 0 view .LVU568
 2093 04bc 86E0      		ldi r24,lo8(6)
 2094 04be F701      		movw r30,r14
 2095               		0:
 2096 04c0 1192      		st Z+,__zero_reg__
 2097 04c2 8A95      		dec r24
 2098 04c4 01F4      		brne 0b
 2099 04c6 00C0      		rjmp .L77
 2100               	.L159:
 661:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2101               		.loc 1 661 25 is_stmt 1 view .LVU569
 661:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2102               		.loc 1 661 28 is_stmt 0 view .LVU570
 2103 04c8 8823      		tst r24
 2104 04ca 01F4      		brne .+2
 2105 04cc 00C0      		rjmp .L77
 661:tmk_core/common/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2106               		.loc 1 661 39 discriminator 1 view .LVU571
 2107 04ce D111      		cpse r29,__zero_reg__
 2108 04d0 00C0      		rjmp .L77
 662:tmk_core/common/action.c ****                             swap_held  = false;
 2109               		.loc 1 662 29 is_stmt 1 view .LVU572
 2110 04d2 8091 0000 		lds r24,swap_hands
 2111 04d6 91E0      		ldi r25,lo8(1)
 2112 04d8 8927      		eor r24,r25
 662:tmk_core/common/action.c ****                             swap_held  = false;
 2113               		.loc 1 662 40 is_stmt 0 view .LVU573
 2114 04da 8093 0000 		sts swap_hands,r24
 2115 04de 00C0      		rjmp .L221
 2116               	.LVL184:
 2117               	.L73:
 2118               	/* epilogue start */
 737:tmk_core/common/action.c **** 
 2119               		.loc 1 737 1 view .LVU574
 2120 04e0 DF91      		pop r29
 2121               	.LVL185:
 737:tmk_core/common/action.c **** 
 2122               		.loc 1 737 1 view .LVU575
 2123 04e2 CF91      		pop r28
 2124               	.LVL186:
 737:tmk_core/common/action.c **** 
 2125               		.loc 1 737 1 view .LVU576
 2126 04e4 1F91      		pop r17
 737:tmk_core/common/action.c **** 
 2127               		.loc 1 737 1 view .LVU577
 2128 04e6 0F91      		pop r16
 2129 04e8 FF90      		pop r15
 2130 04ea EF90      		pop r14
 2131               	.LVL187:
 737:tmk_core/common/action.c **** 
 2132               		.loc 1 737 1 view .LVU578
 2133 04ec DF90      		pop r13
 2134               	.LVL188:
 737:tmk_core/common/action.c **** 
 2135               		.loc 1 737 1 view .LVU579
 2136 04ee CF90      		pop r12
 2137 04f0 BF90      		pop r11
 2138 04f2 AF90      		pop r10
 2139 04f4 9F90      		pop r9
 2140 04f6 8F90      		pop r8
 2141 04f8 0895      		ret
 2142               		.cfi_endproc
 2143               	.LFE116:
 2145               		.section	.text.process_record_handler,"ax",@progbits
 2146               	.global	process_record_handler
 2148               	process_record_handler:
 2149               	.LVL189:
 2150               	.LFB115:
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 2151               		.loc 1 208 50 is_stmt 1 view -0
 2152               		.cfi_startproc
 208:tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 2153               		.loc 1 208 50 is_stmt 0 view .LVU581
 2154 0000 0F93      		push r16
 2155               	.LCFI20:
 2156               		.cfi_def_cfa_offset 3
 2157               		.cfi_offset 16, -2
 2158 0002 1F93      		push r17
 2159               	.LCFI21:
 2160               		.cfi_def_cfa_offset 4
 2161               		.cfi_offset 17, -3
 2162 0004 CF93      		push r28
 2163               	.LCFI22:
 2164               		.cfi_def_cfa_offset 5
 2165               		.cfi_offset 28, -4
 2166 0006 DF93      		push r29
 2167               	.LCFI23:
 2168               		.cfi_def_cfa_offset 6
 2169               		.cfi_offset 29, -5
 2170               	/* prologue: function */
 2171               	/* frame size = 0 */
 2172               	/* stack size = 4 */
 2173               	.L__stack_usage = 4
 2174 0008 EC01      		movw r28,r24
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 2175               		.loc 1 209 5 is_stmt 1 view .LVU582
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 2176               		.loc 1 209 23 is_stmt 0 view .LVU583
 2177 000a 6881      		ld r22,Y
 2178 000c 7981      		ldd r23,Y+1
 2179 000e 8A81      		ldd r24,Y+2
 2180               	.LVL190:
 209:tmk_core/common/action.c ****     dprint("ACTION: ");
 2181               		.loc 1 209 23 view .LVU584
 2182 0010 0E94 0000 		call store_or_get_action
 2183               	.LVL191:
 2184 0014 8C01      		movw r16,r24
 2185               	.LVL192:
 210:tmk_core/common/action.c ****     debug_action(action);
 2186               		.loc 1 210 23 is_stmt 1 view .LVU585
 211:tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2187               		.loc 1 211 5 view .LVU586
 213:tmk_core/common/action.c ****     layer_debug();
 2188               		.loc 1 213 29 view .LVU587
 214:tmk_core/common/action.c ****     dprint(" default_layer_state: ");
 2189               		.loc 1 214 5 view .LVU588
 2190 0016 0E94 0000 		call layer_debug
 2191               	.LVL193:
 215:tmk_core/common/action.c ****     default_layer_debug();
 2192               		.loc 1 215 37 view .LVU589
 216:tmk_core/common/action.c **** #endif
 2193               		.loc 1 216 5 view .LVU590
 2194 001a 0E94 0000 		call default_layer_debug
 2195               	.LVL194:
 218:tmk_core/common/action.c **** 
 2196               		.loc 1 218 15 view .LVU591
 220:tmk_core/common/action.c **** }
 2197               		.loc 1 220 5 view .LVU592
 220:tmk_core/common/action.c **** }
 2198               		.loc 1 220 5 is_stmt 0 view .LVU593
 2199 001e B801      		movw r22,r16
 2200 0020 CE01      		movw r24,r28
 2201               	/* epilogue start */
 221:tmk_core/common/action.c **** 
 2202               		.loc 1 221 1 view .LVU594
 2203 0022 DF91      		pop r29
 2204 0024 CF91      		pop r28
 2205               	.LVL195:
 221:tmk_core/common/action.c **** 
 2206               		.loc 1 221 1 view .LVU595
 2207 0026 1F91      		pop r17
 2208 0028 0F91      		pop r16
 2209               	.LVL196:
 220:tmk_core/common/action.c **** }
 2210               		.loc 1 220 5 view .LVU596
 2211 002a 0C94 0000 		jmp process_action
 2212               	.LVL197:
 220:tmk_core/common/action.c **** }
 2213               		.loc 1 220 5 view .LVU597
 2214               		.cfi_endproc
 2215               	.LFE115:
 2217               		.section	.text.process_record,"ax",@progbits
 2218               	.global	process_record
 2220               	process_record:
 2221               	.LVL198:
 2222               	.LFB114:
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 2223               		.loc 1 190 42 is_stmt 1 view -0
 2224               		.cfi_startproc
 190:tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) {
 2225               		.loc 1 190 42 is_stmt 0 view .LVU599
 2226 0000 CF93      		push r28
 2227               	.LCFI24:
 2228               		.cfi_def_cfa_offset 3
 2229               		.cfi_offset 28, -2
 2230 0002 DF93      		push r29
 2231               	.LCFI25:
 2232               		.cfi_def_cfa_offset 4
 2233               		.cfi_offset 29, -3
 2234               	/* prologue: function */
 2235               	/* frame size = 0 */
 2236               	/* stack size = 2 */
 2237               	.L__stack_usage = 2
 2238 0004 EC01      		movw r28,r24
 191:tmk_core/common/action.c ****         return;
 2239               		.loc 1 191 5 is_stmt 1 view .LVU600
 2240               	.LBB67:
 2241               	.LBI67:
 2242               		.loc 2 48 20 view .LVU601
 2243               	.LBB68:
 2244               		.loc 2 48 51 view .LVU602
 2245               		.loc 2 48 74 is_stmt 0 view .LVU603
 2246 0006 8B81      		ldd r24,Y+3
 2247 0008 9C81      		ldd r25,Y+4
 2248               	.LVL199:
 2249               		.loc 2 48 74 view .LVU604
 2250 000a 892B      		or r24,r25
 2251 000c 01F0      		breq .L233
 2252 000e 8881      		ld r24,Y
 2253 0010 9981      		ldd r25,Y+1
 2254 0012 8923      		and r24,r25
 2255 0014 8F3F      		cpi r24,lo8(-1)
 2256 0016 01F4      		brne .L249
 2257               	.L233:
 2258               	/* epilogue start */
 2259               	.LBE68:
 2260               	.LBE67:
 206:tmk_core/common/action.c **** 
 2261               		.loc 1 206 1 view .LVU605
 2262 0018 DF91      		pop r29
 2263 001a CF91      		pop r28
 2264               	.LVL200:
 206:tmk_core/common/action.c **** 
 2265               		.loc 1 206 1 view .LVU606
 2266 001c 0895      		ret
 2267               	.LVL201:
 2268               	.L238:
 204:tmk_core/common/action.c ****     post_process_record_quantum(record);
 2269               		.loc 1 204 5 is_stmt 1 view .LVU607
 2270 001e CE01      		movw r24,r28
 2271 0020 0E94 0000 		call process_record_handler
 2272               	.LVL202:
 205:tmk_core/common/action.c **** }
 2273               		.loc 1 205 5 view .LVU608
 2274 0024 CE01      		movw r24,r28
 2275               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 2276               		.loc 1 206 1 is_stmt 0 view .LVU609
 2277 0026 DF91      		pop r29
 2278 0028 CF91      		pop r28
 2279               	.LVL203:
 205:tmk_core/common/action.c **** }
 2280               		.loc 1 205 5 view .LVU610
 2281 002a 0C94 0000 		jmp post_process_record_quantum
 2282               	.LVL204:
 2283               	.L249:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2284               		.loc 1 195 5 is_stmt 1 view .LVU611
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2285               		.loc 1 195 10 is_stmt 0 view .LVU612
 2286 002e CE01      		movw r24,r28
 2287 0030 0E94 0000 		call process_record_quantum
 2288               	.LVL205:
 195:tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 2289               		.loc 1 195 8 view .LVU613
 2290 0034 8111      		cpse r24,__zero_reg__
 2291 0036 00C0      		rjmp .L238
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2292               		.loc 1 197 9 is_stmt 1 view .LVU614
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2293               		.loc 1 197 13 is_stmt 0 view .LVU615
 2294 0038 0E94 0000 		call is_oneshot_layer_active
 2295               	.LVL206:
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2296               		.loc 1 197 12 view .LVU616
 2297 003c 8823      		tst r24
 2298 003e 01F0      		breq .L233
 197:tmk_core/common/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2299               		.loc 1 197 39 discriminator 1 view .LVU617
 2300 0040 8A81      		ldd r24,Y+2
 2301 0042 8823      		tst r24
 2302 0044 01F0      		breq .L233
 198:tmk_core/common/action.c ****         }
 2303               		.loc 1 198 13 is_stmt 1 view .LVU618
 2304 0046 82E0      		ldi r24,lo8(2)
 2305               	/* epilogue start */
 206:tmk_core/common/action.c **** 
 2306               		.loc 1 206 1 is_stmt 0 view .LVU619
 2307 0048 DF91      		pop r29
 2308 004a CF91      		pop r28
 2309               	.LVL207:
 198:tmk_core/common/action.c ****         }
 2310               		.loc 1 198 13 view .LVU620
 2311 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2312               	.LVL208:
 2313               		.cfi_endproc
 2314               	.LFE114:
 2316               		.section	.text.process_record_nocache,"ax",@progbits
 2317               	.global	process_record_nocache
 2319               	process_record_nocache:
 2320               	.LVL209:
 2321               	.LFB110:
 148:tmk_core/common/action.c ****     disable_action_cache = true;
 2322               		.loc 1 148 50 is_stmt 1 view -0
 2323               		.cfi_startproc
 2324               	/* prologue: function */
 2325               	/* frame size = 0 */
 2326               	/* stack size = 0 */
 2327               	.L__stack_usage = 0
 149:tmk_core/common/action.c ****     process_record(record);
 2328               		.loc 1 149 5 view .LVU622
 149:tmk_core/common/action.c ****     process_record(record);
 2329               		.loc 1 149 26 is_stmt 0 view .LVU623
 2330 0000 21E0      		ldi r18,lo8(1)
 2331 0002 2093 0000 		sts disable_action_cache,r18
 150:tmk_core/common/action.c ****     disable_action_cache = false;
 2332               		.loc 1 150 5 is_stmt 1 view .LVU624
 2333 0006 0E94 0000 		call process_record
 2334               	.LVL210:
 151:tmk_core/common/action.c **** }
 2335               		.loc 1 151 5 view .LVU625
 151:tmk_core/common/action.c **** }
 2336               		.loc 1 151 26 is_stmt 0 view .LVU626
 2337 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2338               	/* epilogue start */
 152:tmk_core/common/action.c **** #else
 2339               		.loc 1 152 1 view .LVU627
 2340 000e 0895      		ret
 2341               		.cfi_endproc
 2342               	.LFE110:
 2344               		.section	.text.register_weak_mods,"ax",@progbits
 2345               	.global	register_weak_mods
 2347               	register_weak_mods:
 2348               	.LVL211:
 2349               	.LFB122:
 934:tmk_core/common/action.c **** 
 935:tmk_core/common/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:tmk_core/common/action.c ****  *
 937:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to register.
 938:tmk_core/common/action.c ****  */
 939:tmk_core/common/action.c **** void register_weak_mods(uint8_t mods) {
 2350               		.loc 1 939 39 is_stmt 1 view -0
 2351               		.cfi_startproc
 2352               	/* prologue: function */
 2353               	/* frame size = 0 */
 2354               	/* stack size = 0 */
 2355               	.L__stack_usage = 0
 940:tmk_core/common/action.c ****     if (mods) {
 2356               		.loc 1 940 5 view .LVU629
 2357               		.loc 1 940 8 is_stmt 0 view .LVU630
 2358 0000 8823      		tst r24
 2359 0002 01F0      		breq .L252
 941:tmk_core/common/action.c ****         add_weak_mods(mods);
 2360               		.loc 1 941 9 is_stmt 1 view .LVU631
 2361 0004 0E94 0000 		call add_weak_mods
 2362               	.LVL212:
 942:tmk_core/common/action.c ****         send_keyboard_report();
 2363               		.loc 1 942 9 view .LVU632
 2364 0008 0C94 0000 		jmp send_keyboard_report
 2365               	.LVL213:
 2366               	.L252:
 2367               	/* epilogue start */
 943:tmk_core/common/action.c ****     }
 944:tmk_core/common/action.c **** }
 2368               		.loc 1 944 1 is_stmt 0 view .LVU633
 2369 000c 0895      		ret
 2370               		.cfi_endproc
 2371               	.LFE122:
 2373               		.section	.text.unregister_weak_mods,"ax",@progbits
 2374               	.global	unregister_weak_mods
 2376               	unregister_weak_mods:
 2377               	.LVL214:
 2378               	.LFB123:
 945:tmk_core/common/action.c **** 
 946:tmk_core/common/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:tmk_core/common/action.c ****  *
 948:tmk_core/common/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:tmk_core/common/action.c ****  */
 950:tmk_core/common/action.c **** void unregister_weak_mods(uint8_t mods) {
 2379               		.loc 1 950 41 is_stmt 1 view -0
 2380               		.cfi_startproc
 2381               	/* prologue: function */
 2382               	/* frame size = 0 */
 2383               	/* stack size = 0 */
 2384               	.L__stack_usage = 0
 951:tmk_core/common/action.c ****     if (mods) {
 2385               		.loc 1 951 5 view .LVU635
 2386               		.loc 1 951 8 is_stmt 0 view .LVU636
 2387 0000 8823      		tst r24
 2388 0002 01F0      		breq .L254
 952:tmk_core/common/action.c ****         del_weak_mods(mods);
 2389               		.loc 1 952 9 is_stmt 1 view .LVU637
 2390 0004 0E94 0000 		call del_weak_mods
 2391               	.LVL215:
 953:tmk_core/common/action.c ****         send_keyboard_report();
 2392               		.loc 1 953 9 view .LVU638
 2393 0008 0C94 0000 		jmp send_keyboard_report
 2394               	.LVL216:
 2395               	.L254:
 2396               	/* epilogue start */
 954:tmk_core/common/action.c ****     }
 955:tmk_core/common/action.c **** }
 2397               		.loc 1 955 1 is_stmt 0 view .LVU639
 2398 000c 0895      		ret
 2399               		.cfi_endproc
 2400               	.LFE123:
 2402               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2403               	.global	clear_keyboard_but_mods_and_keys
 2405               	clear_keyboard_but_mods_and_keys:
 2406               	.LFB126:
 956:tmk_core/common/action.c **** 
 957:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:tmk_core/common/action.c ****  *
 959:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 960:tmk_core/common/action.c ****  */
 961:tmk_core/common/action.c **** void clear_keyboard(void) {
 962:tmk_core/common/action.c ****     clear_mods();
 963:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 964:tmk_core/common/action.c **** }
 965:tmk_core/common/action.c **** 
 966:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:tmk_core/common/action.c ****  *
 968:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 969:tmk_core/common/action.c ****  */
 970:tmk_core/common/action.c **** void clear_keyboard_but_mods(void) {
 971:tmk_core/common/action.c ****     clear_keys();
 972:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 973:tmk_core/common/action.c **** }
 974:tmk_core/common/action.c **** 
 975:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:tmk_core/common/action.c ****  *
 977:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 978:tmk_core/common/action.c ****  */
 979:tmk_core/common/action.c **** void clear_keyboard_but_mods_and_keys() {
 2407               		.loc 1 979 41 is_stmt 1 view -0
 2408               		.cfi_startproc
 2409               	/* prologue: function */
 2410               	/* frame size = 0 */
 2411               	/* stack size = 0 */
 2412               	.L__stack_usage = 0
 980:tmk_core/common/action.c ****     clear_weak_mods();
 2413               		.loc 1 980 5 view .LVU641
 2414 0000 0E94 0000 		call clear_weak_mods
 2415               	.LVL217:
 981:tmk_core/common/action.c ****     clear_macro_mods();
 2416               		.loc 1 981 5 view .LVU642
 2417 0004 0E94 0000 		call clear_macro_mods
 2418               	.LVL218:
 982:tmk_core/common/action.c ****     send_keyboard_report();
 2419               		.loc 1 982 5 view .LVU643
 2420 0008 0E94 0000 		call send_keyboard_report
 2421               	.LVL219:
 983:tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 984:tmk_core/common/action.c ****     mousekey_clear();
 2422               		.loc 1 984 5 view .LVU644
 2423 000c 0E94 0000 		call mousekey_clear
 2424               	.LVL220:
 985:tmk_core/common/action.c ****     mousekey_send();
 2425               		.loc 1 985 5 view .LVU645
 2426 0010 0E94 0000 		call mousekey_send
 2427               	.LVL221:
 986:tmk_core/common/action.c **** #endif
 987:tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 988:tmk_core/common/action.c ****     host_system_send(0);
 2428               		.loc 1 988 5 view .LVU646
 2429 0014 90E0      		ldi r25,0
 2430 0016 80E0      		ldi r24,0
 2431 0018 0E94 0000 		call host_system_send
 2432               	.LVL222:
 989:tmk_core/common/action.c ****     host_consumer_send(0);
 2433               		.loc 1 989 5 view .LVU647
 2434 001c 90E0      		ldi r25,0
 2435 001e 80E0      		ldi r24,0
 2436 0020 0C94 0000 		jmp host_consumer_send
 2437               	.LVL223:
 2438               		.cfi_endproc
 2439               	.LFE126:
 2441               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2442               	.global	clear_keyboard_but_mods
 2444               	clear_keyboard_but_mods:
 2445               	.LFB125:
 970:tmk_core/common/action.c ****     clear_keys();
 2446               		.loc 1 970 36 view -0
 2447               		.cfi_startproc
 2448               	/* prologue: function */
 2449               	/* frame size = 0 */
 2450               	/* stack size = 0 */
 2451               	.L__stack_usage = 0
 971:tmk_core/common/action.c ****     clear_keyboard_but_mods_and_keys();
 2452               		.loc 1 971 5 view .LVU649
 2453 0000 0E94 0000 		call clear_keys
 2454               	.LVL224:
 972:tmk_core/common/action.c **** }
 2455               		.loc 1 972 5 view .LVU650
 2456 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2457               	.LVL225:
 2458               		.cfi_endproc
 2459               	.LFE125:
 2461               		.section	.text.clear_keyboard,"ax",@progbits
 2462               	.global	clear_keyboard
 2464               	clear_keyboard:
 2465               	.LFB124:
 961:tmk_core/common/action.c ****     clear_mods();
 2466               		.loc 1 961 27 view -0
 2467               		.cfi_startproc
 2468               	/* prologue: function */
 2469               	/* frame size = 0 */
 2470               	/* stack size = 0 */
 2471               	.L__stack_usage = 0
 962:tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2472               		.loc 1 962 5 view .LVU652
 2473 0000 0E94 0000 		call clear_mods
 2474               	.LVL226:
 963:tmk_core/common/action.c **** }
 2475               		.loc 1 963 5 view .LVU653
 2476 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2477               	.LVL227:
 2478               		.cfi_endproc
 2479               	.LFE124:
 2481               		.section	.text.is_tap_action,"ax",@progbits
 2482               	.global	is_tap_action
 2484               	is_tap_action:
 2485               	.LVL228:
 2486               	.LFB128:
 990:tmk_core/common/action.c **** #endif
 991:tmk_core/common/action.c **** }
 992:tmk_core/common/action.c **** 
 993:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:tmk_core/common/action.c ****  *
 995:tmk_core/common/action.c ****  * FIXME: Needs documentation.
 996:tmk_core/common/action.c ****  */
 997:tmk_core/common/action.c **** bool is_tap_key(keypos_t key) {
 998:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 999:tmk_core/common/action.c ****     return is_tap_action(action);
1000:tmk_core/common/action.c **** }
1001:tmk_core/common/action.c **** 
1002:tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:tmk_core/common/action.c ****  *
1004:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1005:tmk_core/common/action.c ****  */
1006:tmk_core/common/action.c **** bool is_tap_action(action_t action) {
 2487               		.loc 1 1006 37 view -0
 2488               		.cfi_startproc
 2489               	/* prologue: function */
 2490               	/* frame size = 0 */
 2491               	/* stack size = 0 */
 2492               	.L__stack_usage = 0
1007:tmk_core/common/action.c ****     switch (action.kind.id) {
 2493               		.loc 1 1007 5 view .LVU655
 2494               		.loc 1 1007 24 is_stmt 0 view .LVU656
 2495 0000 E92F      		mov r30,r25
 2496 0002 E295      		swap r30
 2497 0004 EF70      		andi r30,lo8(15)
 2498               		.loc 1 1007 5 view .LVU657
 2499 0006 E250      		subi r30,lo8(-(-2))
 2500 0008 EE30      		cpi r30,lo8(14)
 2501 000a 00F4      		brsh .L268
 2502 000c F0E0      		ldi r31,0
 2503 000e E050      		subi r30,lo8(-(gs(.L262)))
 2504 0010 F040      		sbci r31,hi8(-(gs(.L262)))
 2505 0012 0C94 0000 		jmp __tablejump2__
 2506               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2507               		.p2align	1
 2508               	.L262:
 2509 0000 0000      		.word gs(.L263)
 2510 0002 0000      		.word gs(.L263)
 2511 0004 0000      		.word gs(.L268)
 2512 0006 0000      		.word gs(.L268)
 2513 0008 0000      		.word gs(.L264)
 2514 000a 0000      		.word gs(.L268)
 2515 000c 0000      		.word gs(.L268)
 2516 000e 0000      		.word gs(.L268)
 2517 0010 0000      		.word gs(.L263)
 2518 0012 0000      		.word gs(.L263)
 2519 0014 0000      		.word gs(.L261)
 2520 0016 0000      		.word gs(.L268)
 2521 0018 0000      		.word gs(.L268)
 2522 001a 0000      		.word gs(.L261)
 2523               		.section	.text.is_tap_action
 2524               	.L263:
1008:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1009:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1010:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1011:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1012:tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2525               		.loc 1 1012 13 is_stmt 1 view .LVU658
 2526 0016 803F      		cpi r24,lo8(-16)
 2527 0018 01F0      		breq .L271
 2528 001a 00F4      		brsh .L265
 2529 001c 883E      		cpi r24,lo8(-24)
 2530 001e 00F4      		brsh .L268
 2531               	.L271:
1013:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1014:tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
1015:tmk_core/common/action.c ****                 case OP_ONESHOT:
1016:tmk_core/common/action.c ****                     return true;
 2532               		.loc 1 1016 28 is_stmt 0 view .LVU659
 2533 0020 81E0      		ldi r24,lo8(1)
 2534               	.LVL229:
 2535               	/* epilogue start */
1017:tmk_core/common/action.c ****             }
1018:tmk_core/common/action.c ****             return false;
1019:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1020:tmk_core/common/action.c ****             switch (action.swap.code) {
1021:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
1022:tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
1023:tmk_core/common/action.c ****                     return true;
1024:tmk_core/common/action.c ****             }
1025:tmk_core/common/action.c ****             return false;
1026:tmk_core/common/action.c ****         case ACT_MACRO:
1027:tmk_core/common/action.c ****         case ACT_FUNCTION:
1028:tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) {
1029:tmk_core/common/action.c ****                 return true;
1030:tmk_core/common/action.c ****             }
1031:tmk_core/common/action.c ****             return false;
1032:tmk_core/common/action.c ****     }
1033:tmk_core/common/action.c ****     return false;
1034:tmk_core/common/action.c **** }
 2536               		.loc 1 1034 1 view .LVU660
 2537 0022 0895      		ret
 2538               	.LVL230:
 2539               	.L265:
 2540               		.loc 1 1034 1 view .LVU661
 2541 0024 843F      		cpi r24,lo8(-12)
 2542 0026 01F0      		breq .L271
 2543               	.L268:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2544               		.loc 1 1018 20 view .LVU662
 2545 0028 80E0      		ldi r24,0
 2546               	.LVL231:
1018:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2547               		.loc 1 1018 20 view .LVU663
 2548 002a 0895      		ret
 2549               	.LVL232:
 2550               	.L264:
1020:tmk_core/common/action.c ****                 case KC_NO ... KC_RGUI:
 2551               		.loc 1 1020 13 is_stmt 1 view .LVU664
 2552 002c 883E      		cpi r24,lo8(-24)
 2553 002e 00F0      		brlo .L271
 2554 0030 813F      		cpi r24,lo8(-15)
 2555 0032 01F4      		brne .L268
 2556 0034 00C0      		rjmp .L271
 2557               	.L261:
1028:tmk_core/common/action.c ****                 return true;
 2558               		.loc 1 1028 13 view .LVU665
1028:tmk_core/common/action.c ****                 return true;
 2559               		.loc 1 1028 16 is_stmt 0 view .LVU666
 2560 0036 93FB      		bst r25,3
 2561 0038 8827      		clr r24
 2562 003a 80F9      		bld r24,0
 2563               	.LVL233:
1028:tmk_core/common/action.c ****                 return true;
 2564               		.loc 1 1028 16 view .LVU667
 2565 003c 0895      		ret
 2566               		.cfi_endproc
 2567               	.LFE128:
 2569               		.section	.text.is_tap_key,"ax",@progbits
 2570               	.global	is_tap_key
 2572               	is_tap_key:
 2573               	.LVL234:
 2574               	.LFB127:
 997:tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2575               		.loc 1 997 31 is_stmt 1 view -0
 2576               		.cfi_startproc
 2577               	/* prologue: function */
 2578               	/* frame size = 0 */
 2579               	/* stack size = 0 */
 2580               	.L__stack_usage = 0
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 2581               		.loc 1 998 5 view .LVU669
 998:tmk_core/common/action.c ****     return is_tap_action(action);
 2582               		.loc 1 998 23 is_stmt 0 view .LVU670
 2583 0000 0E94 0000 		call layer_switch_get_action
 2584               	.LVL235:
 999:tmk_core/common/action.c **** }
 2585               		.loc 1 999 5 is_stmt 1 view .LVU671
 999:tmk_core/common/action.c **** }
 2586               		.loc 1 999 12 is_stmt 0 view .LVU672
 2587 0004 0C94 0000 		jmp is_tap_action
 2588               	.LVL236:
 2589               		.cfi_endproc
 2590               	.LFE127:
 2592               		.section	.text.debug_event,"ax",@progbits
 2593               	.global	debug_event
 2595               	debug_event:
 2596               	.LFB129:
1035:tmk_core/common/action.c **** 
1036:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1037:tmk_core/common/action.c ****  *
1038:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1039:tmk_core/common/action.c ****  */
1040:tmk_core/common/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2597               		.loc 1 1040 36 is_stmt 1 view -0
 2598               		.cfi_startproc
 2599 0000 CF93      		push r28
 2600               	.LCFI26:
 2601               		.cfi_def_cfa_offset 3
 2602               		.cfi_offset 28, -2
 2603 0002 DF93      		push r29
 2604               	.LCFI27:
 2605               		.cfi_def_cfa_offset 4
 2606               		.cfi_offset 29, -3
 2607 0004 00D0      		rcall .
 2608 0006 00D0      		rcall .
 2609 0008 0F92      		push __tmp_reg__
 2610               	.LCFI28:
 2611               		.cfi_def_cfa_offset 9
 2612 000a CDB7      		in r28,__SP_L__
 2613 000c DEB7      		in r29,__SP_H__
 2614               	.LCFI29:
 2615               		.cfi_def_cfa_register 28
 2616               	/* prologue: function */
 2617               	/* frame size = 5 */
 2618               	/* stack size = 7 */
 2619               	.L__stack_usage = 7
 2620               		.loc 1 1040 138 view .LVU674
 2621               	/* epilogue start */
 2622               		.loc 1 1040 1 is_stmt 0 view .LVU675
 2623 000e 0F90      		pop __tmp_reg__
 2624 0010 0F90      		pop __tmp_reg__
 2625 0012 0F90      		pop __tmp_reg__
 2626 0014 0F90      		pop __tmp_reg__
 2627 0016 0F90      		pop __tmp_reg__
 2628 0018 DF91      		pop r29
 2629 001a CF91      		pop r28
 2630 001c 0895      		ret
 2631               		.cfi_endproc
 2632               	.LFE129:
 2634               		.section	.text.debug_record,"ax",@progbits
 2635               	.global	debug_record
 2637               	debug_record:
 2638               	.LFB130:
1041:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1042:tmk_core/common/action.c ****  *
1043:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1044:tmk_core/common/action.c ****  */
1045:tmk_core/common/action.c **** void debug_record(keyrecord_t record) {
 2639               		.loc 1 1045 39 is_stmt 1 view -0
 2640               		.cfi_startproc
 2641 0000 CF93      		push r28
 2642               	.LCFI30:
 2643               		.cfi_def_cfa_offset 3
 2644               		.cfi_offset 28, -2
 2645 0002 DF93      		push r29
 2646               	.LCFI31:
 2647               		.cfi_def_cfa_offset 4
 2648               		.cfi_offset 29, -3
 2649 0004 00D0      		rcall .
 2650 0006 00D0      		rcall .
 2651 0008 00D0      		rcall .
 2652               	.LCFI32:
 2653               		.cfi_def_cfa_offset 10
 2654 000a CDB7      		in r28,__SP_L__
 2655 000c DEB7      		in r29,__SP_H__
 2656               	.LCFI33:
 2657               		.cfi_def_cfa_register 28
 2658               	/* prologue: function */
 2659               	/* frame size = 6 */
 2660               	/* stack size = 8 */
 2661               	.L__stack_usage = 8
1046:tmk_core/common/action.c ****     debug_event(record.event);
 2662               		.loc 1 1046 5 view .LVU677
1047:tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
1048:tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2663               		.loc 1 1048 77 view .LVU678
 2664               	/* epilogue start */
1049:tmk_core/common/action.c **** #endif
1050:tmk_core/common/action.c **** }
 2665               		.loc 1 1050 1 is_stmt 0 view .LVU679
 2666 000e 2696      		adiw r28,6
 2667 0010 0FB6      		in __tmp_reg__,__SREG__
 2668 0012 F894      		cli
 2669 0014 DEBF      		out __SP_H__,r29
 2670 0016 0FBE      		out __SREG__,__tmp_reg__
 2671 0018 CDBF      		out __SP_L__,r28
 2672 001a DF91      		pop r29
 2673 001c CF91      		pop r28
 2674 001e 0895      		ret
 2675               		.cfi_endproc
 2676               	.LFE130:
 2678               		.section	.text.debug_action,"ax",@progbits
 2679               	.global	debug_action
 2681               	debug_action:
 2682               	.LVL237:
 2683               	.LFB131:
1051:tmk_core/common/action.c **** 
1052:tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
1053:tmk_core/common/action.c ****  *
1054:tmk_core/common/action.c ****  * FIXME: Needs documentation.
1055:tmk_core/common/action.c ****  */
1056:tmk_core/common/action.c **** void debug_action(action_t action) {
 2684               		.loc 1 1056 36 is_stmt 1 view -0
 2685               		.cfi_startproc
 2686               	/* prologue: function */
 2687               	/* frame size = 0 */
 2688               	/* stack size = 0 */
 2689               	.L__stack_usage = 0
1057:tmk_core/common/action.c ****     switch (action.kind.id) {
 2690               		.loc 1 1057 5 view .LVU681
1058:tmk_core/common/action.c ****         case ACT_LMODS:
1059:tmk_core/common/action.c ****             dprint("ACT_LMODS");
1060:tmk_core/common/action.c ****             break;
1061:tmk_core/common/action.c ****         case ACT_RMODS:
1062:tmk_core/common/action.c ****             dprint("ACT_RMODS");
1063:tmk_core/common/action.c ****             break;
1064:tmk_core/common/action.c ****         case ACT_LMODS_TAP:
1065:tmk_core/common/action.c ****             dprint("ACT_LMODS_TAP");
1066:tmk_core/common/action.c ****             break;
1067:tmk_core/common/action.c ****         case ACT_RMODS_TAP:
1068:tmk_core/common/action.c ****             dprint("ACT_RMODS_TAP");
1069:tmk_core/common/action.c ****             break;
1070:tmk_core/common/action.c ****         case ACT_USAGE:
1071:tmk_core/common/action.c ****             dprint("ACT_USAGE");
1072:tmk_core/common/action.c ****             break;
1073:tmk_core/common/action.c ****         case ACT_MOUSEKEY:
1074:tmk_core/common/action.c ****             dprint("ACT_MOUSEKEY");
1075:tmk_core/common/action.c ****             break;
1076:tmk_core/common/action.c ****         case ACT_LAYER:
1077:tmk_core/common/action.c ****             dprint("ACT_LAYER");
1078:tmk_core/common/action.c ****             break;
1079:tmk_core/common/action.c ****         case ACT_LAYER_MODS:
1080:tmk_core/common/action.c ****             dprint("ACT_LAYER_MODS");
1081:tmk_core/common/action.c ****             break;
1082:tmk_core/common/action.c ****         case ACT_LAYER_TAP:
1083:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP");
1084:tmk_core/common/action.c ****             break;
1085:tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
1086:tmk_core/common/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1087:tmk_core/common/action.c ****             break;
1088:tmk_core/common/action.c ****         case ACT_MACRO:
1089:tmk_core/common/action.c ****             dprint("ACT_MACRO");
1090:tmk_core/common/action.c ****             break;
1091:tmk_core/common/action.c ****         case ACT_FUNCTION:
1092:tmk_core/common/action.c ****             dprint("ACT_FUNCTION");
1093:tmk_core/common/action.c ****             break;
1094:tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
1095:tmk_core/common/action.c ****             dprint("ACT_SWAP_HANDS");
1096:tmk_core/common/action.c ****             break;
1097:tmk_core/common/action.c ****         default:
1098:tmk_core/common/action.c ****             dprint("UNKNOWN");
1099:tmk_core/common/action.c ****             break;
1100:tmk_core/common/action.c ****     }
1101:tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2691               		.loc 1 1101 75 view .LVU682
 2692               	/* epilogue start */
1102:tmk_core/common/action.c **** }
 2693               		.loc 1 1102 1 is_stmt 0 view .LVU683
 2694 0000 0895      		ret
 2695               		.cfi_endproc
 2696               	.LFE131:
 2698               		.section	.rodata.CSWTCH.23,"a"
 2701               	CSWTCH.23:
 2702 0000 E200      		.word	226
 2703 0002 E900      		.word	233
 2704 0004 EA00      		.word	234
 2705 0006 B500      		.word	181
 2706 0008 B600      		.word	182
 2707 000a B700      		.word	183
 2708 000c CD00      		.word	205
 2709 000e 8301      		.word	387
 2710 0010 CC00      		.word	204
 2711 0012 8A01      		.word	394
 2712 0014 9201      		.word	402
 2713 0016 9401      		.word	404
 2714 0018 2102      		.word	545
 2715 001a 2302      		.word	547
 2716 001c 2402      		.word	548
 2717 001e 2502      		.word	549
 2718 0020 2602      		.word	550
 2719 0022 2702      		.word	551
 2720 0024 2A02      		.word	554
 2721 0026 B300      		.word	179
 2722 0028 B400      		.word	180
 2723 002a 6F00      		.word	111
 2724 002c 7000      		.word	112
 2725               		.section	.rodata.CSWTCH.22,"a"
 2728               	CSWTCH.22:
 2729 0000 81        		.byte	-127
 2730 0001 82        		.byte	-126
 2731 0002 83        		.byte	-125
 2732               		.section	.bss.swap_state.5258,"aw",@nobits
 2735               	swap_state.5258:
 2736 0000 0000 0000 		.zero	14
 2736      0000 0000 
 2736      0000 0000 
 2736      0000 
 2737               	.global	disable_action_cache
 2738               		.section	.bss.disable_action_cache,"aw",@nobits
 2741               	disable_action_cache:
 2742 0000 00        		.zero	1
 2743               	.global	swap_held
 2744               		.section	.bss.swap_held,"aw",@nobits
 2747               	swap_held:
 2748 0000 00        		.zero	1
 2749               	.global	swap_hands
 2750               		.section	.bss.swap_hands,"aw",@nobits
 2753               	swap_hands:
 2754 0000 00        		.zero	1
 2755               		.comm	tp_buttons,2,1
 2756               		.text
 2757               	.Letext0:
 2758               		.file 5 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdint.h"
 2759               		.file 6 "tmk_core/common/keycode.h"
 2760               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2761               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2762               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 2763               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2764               		.file 11 "/usr/local/Cellar/avr-gcc@8/8.4.0/avr/include/stdio.h"
 2765               		.file 12 "tmk_core/common/host.h"
 2766               		.file 13 "tmk_core/common/mousekey.h"
 2767               		.file 14 "tmk_core/common/command.h"
 2768               		.file 15 "tmk_core/common/action_code.h"
 2769               		.file 16 "tmk_core/common/action.h"
 2770               		.file 17 "tmk_core/common/action_layer.h"
 2771               		.file 18 "tmk_core/common/action_util.h"
 2772               		.file 19 "tmk_core/common/debug.h"
 2773               		.file 20 "tmk_core/common/led.h"
 2774               		.file 21 "tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:4      *ABS*:000000000000003f __SREG__
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:13     .text.process_hand_swap:0000000000000000 process_hand_swap
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2735   .bss.swap_state.5258:0000000000000000 swap_state.5258
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2753   .bss.swap_hands:0000000000000000 swap_hands
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:130    .text.action_exec:0000000000000000 action_exec
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:231    .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:253    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:272    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2747   .bss.swap_held:0000000000000000 swap_held
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:322    .text.register_code:0000000000000000 register_code
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2728   .rodata.CSWTCH.22:0000000000000000 CSWTCH.22
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2701   .rodata.CSWTCH.23:0000000000000000 CSWTCH.23
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:645    .text.unregister_code:0000000000000000 unregister_code
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:813    .text.tap_code:0000000000000000 tap_code
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:877    .text.register_mods:0000000000000000 register_mods
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:906    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:935    .text.process_action:0000000000000000 process_action
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2220   .text.process_record:0000000000000000 process_record
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2148   .text.process_record_handler:0000000000000000 process_record_handler
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2319   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2741   .bss.disable_action_cache:0000000000000000 disable_action_cache
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2347   .text.register_weak_mods:0000000000000000 register_weak_mods
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2376   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2405   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2444   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2464   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2484   .text.is_tap_action:0000000000000000 is_tap_action
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2572   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2595   .text.debug_event:0000000000000000 debug_event
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2637   .text.debug_record:0000000000000000 debug_record
/var/folders/_9/m54r6fns3hz487qfhcdsxzvr0000gn/T//ccLdDUkI.s:2681   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
hand_swap_config
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
keyboard_report
is_key_pressed
add_mods
host_system_send
host_consumer_send
mousekey_on
mousekey_send
del_mods
mousekey_off
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
use_oneshot_swaphands
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
set_oneshot_swaphands
release_oneshot_swaphands
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
mousekey_clear
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
